{"config": {"lang": ["en"], "separator": "[\\s\\-]+", "pipeline": ["stopWordFilter"]}, "docs": [{"location": "", "title": "Welcome to GraphRAG", "text": "<p>\ud83d\udc49 Microsoft Research Blog Post  \ud83d\udc49 GraphRAG Accelerator  \ud83d\udc49 GraphRAG Arxiv</p> <p> </p> <p> Figure 1: An LLM-generated knowledge graph built using GPT-4 Turbo. </p> <p>GraphRAG is a structured, hierarchical approach to Retrieval Augmented Generation (RAG), as opposed to naive semantic-search approaches using plain text snippets. The GraphRAG process involves extracting a knowledge graph out of raw text, building a community hierarchy, generating summaries for these communities, and then leveraging these structures when perform RAG-based tasks.</p> <p>To learn more about GraphRAG and how it can be used to enhance your LLMs ability to reason about your private data, please visit the Microsoft Research Blog Post.</p>"}, {"location": "#solution-accelerator", "title": "Solution Accelerator \ud83d\ude80", "text": "<p>To quickstart the GraphRAG system we recommend trying the Solution Accelerator package. This provides a user-friendly end-to-end experience with Azure resources.</p>"}, {"location": "#get-started-with-graphrag", "title": "Get Started with GraphRAG \ud83d\ude80", "text": "<p>To start using GraphRAG, check out the Get Started guide. For a deeper dive into the main sub-systems, please visit the docpages for the Indexer and Query packages.</p>"}, {"location": "#graphrag-vs-baseline-rag", "title": "GraphRAG vs Baseline RAG \ud83d\udd0d", "text": "<p>Retrieval-Augmented Generation (RAG) is a technique to improve LLM outputs using real-world information. This technique is an important part of most LLM-based tools and the majority of RAG approaches use vector similarity as the search technique, which we call Baseline RAG. GraphRAG uses knowledge graphs to provide substantial improvements in question-and-answer performance when reasoning about complex information. RAG techniques have shown promise in helping LLMs to reason about private datasets - data that the LLM is not trained on and has never seen before, such as an enterprise\u2019s proprietary research, business documents, or communications. Baseline RAG was created to help solve this problem, but we observe situations where baseline RAG performs very poorly. For example:</p> <ul> <li>Baseline RAG struggles to connect the dots. This happens when answering a question requires traversing disparate pieces of information through their shared attributes in order to provide new synthesized insights.</li> <li>Baseline RAG performs poorly when being asked to holistically understand summarized semantic concepts over large data collections or even singular large documents.</li> </ul> <p>To address this, the tech community is working to develop methods that extend and enhance RAG. Microsoft Research\u2019s new approach, GraphRAG, uses LLMs to create a knowledge graph based on an input corpus. This graph, along with community summaries and graph machine learning outputs, are used to augment prompts at query time. GraphRAG shows substantial improvement in answering the two classes of questions described above, demonstrating intelligence or mastery that outperforms other approaches previously applied to private datasets.</p>"}, {"location": "#the-graphrag-process", "title": "The GraphRAG Process \ud83e\udd16", "text": "<p>GraphRAG builds upon our prior research and tooling using graph machine learning. The basic steps of the GraphRAG process are as follows:</p>"}, {"location": "#index", "title": "Index", "text": "<ul> <li>Slice up an input corpus into a series of TextUnits, which act as analyzable units for the rest of the process, and provide fine-grained references in our outputs.</li> <li>Extract all entities, relationships, and key claims from the TextUnits using an LLM.</li> <li>Perform a hierarchical clustering of the graph using the Leiden technique. To see this visually, check out Figure 1 above. Each circle is an entity (e.g., a person, place, or organization), with the size representing the degree of the entity, and the color representing its community.</li> <li>Generate summaries of each community and its constituents from the bottom-up. This aids in holistic understanding of the dataset.</li> </ul>"}, {"location": "#query", "title": "Query", "text": "<p>At query time, these structures are used to provide materials for the LLM context window when answering a question. The primary query modes are:</p> <ul> <li>Global Search for reasoning about holistic questions about the corpus by leveraging the community summaries.</li> <li>Local Search for reasoning about specific entities by fanning-out to their neighbors and associated concepts.</li> </ul>"}, {"location": "#prompt-tuning", "title": "Prompt Tuning", "text": "<p>Using GraphRAG with your data out of the box may not yield the best possible results. We strongly recommend to fine-tune your prompts following the Prompt Tuning Guide in our documentation.</p>"}, {"location": "blog_posts/", "title": "Microsoft Research Blog", "text": "<ul> <li> <p> GraphRAG: Unlocking LLM discovery on narrative private data</p> <p>Published February 13, 2024 <p>By Jonathan Larson, Senior Principal Data Architect; Steven Truitt, Principal Program Manager</p> <li> <p> GraphRAG: New tool for complex data discovery now on GitHub</p> <p>Published July 2, 2024 <p>By Darren Edge, Senior Director; Ha Trinh, Senior Data Scientist; Steven Truitt, Principal Program Manager; Jonathan Larson, Senior Principal Data Architect</p> <li> <p> GraphRAG auto-tuning provides rapid adaptation to new domains</p> <p>Published September 9, 2024 <p>By Alonso Guevara Fern\u00e1ndez, Sr. Software Engineer; Katy Smith, Data Scientist II; Joshua Bradley, Senior Data Scientist; Darren Edge, Senior Director; Ha Trinh, Senior Data Scientist; Sarah Smith, Senior Program Manager; Ben Cutler, Senior Director; Steven Truitt, Principal Program Manager; Jonathan Larson, Senior Principal Data Architect</p>"}, {"location": "cli/", "title": "CLI Reference", "text": "<p>This page documents the command-line interface of the graphrag library.</p>"}, {"location": "cli/#graphrag", "title": "graphrag", "text": "<p>GraphRAG: A graph-based retrieval-augmented generation (RAG) system.</p> <p>Usage:</p> <pre><code> [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> <pre><code>  --install-completion  Install completion for the current shell.\n  --show-completion     Show completion for the current shell, to copy it or\n                        customize the installation.\n</code></pre>"}, {"location": "cli/#index", "title": "index", "text": "<p>Build a knowledge graph index.</p> <p>Usage:</p> <pre><code> index [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  --config PATH                   The configuration to use.\n  --root PATH                     The project root directory.  [default: .]\n  --verbose / --no-verbose        Run the indexing pipeline with verbose\n                                  logging  [default: no-verbose]\n  --memprofile / --no-memprofile  Run the indexing pipeline with memory\n                                  profiling  [default: no-memprofile]\n  --resume TEXT                   Resume a given indexing run\n  --reporter [rich|print|none]    The progress reporter to use.  [default:\n                                  rich]\n  --emit TEXT                     The data formats to emit, comma-separated.\n                                  [default: parquet]\n  --dry-run / --no-dry-run        Run the indexing pipeline without executing\n                                  any steps to inspect and validate the\n                                  configuration.  [default: no-dry-run]\n  --cache / --no-cache            Use LLM cache.  [default: cache]\n  --skip-validation / --no-skip-validation\n                                  Skip any preflight validation. Useful when\n                                  running no LLM steps.  [default: no-skip-\n                                  validation]\n  --output PATH                   Indexing pipeline output directory.\n                                  Overrides storage.base_dir in the\n                                  configuration file.\n</code></pre>"}, {"location": "cli/#init", "title": "init", "text": "<p>Generate a default configuration file.</p> <p>Usage:</p> <pre><code> init [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  --root PATH  The project root directory.  [required]\n</code></pre>"}, {"location": "cli/#prompt-tune", "title": "prompt-tune", "text": "<p>Generate custom graphrag prompts with your own data (i.e. auto templating).</p> <p>Usage:</p> <pre><code> prompt-tune [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  --root PATH                     The project root directory.  [default: .]\n  --config PATH                   The configuration to use.\n  --domain TEXT                   The domain your input data is related to.\n                                  For example 'space science', 'microbiology',\n                                  'environmental news'. If not defined, a\n                                  domain will be inferred from the input data.\n  --selection-method [all|random|top|auto]\n                                  The text chunk selection method.  [default:\n                                  random]\n  --n-subset-max INTEGER          The number of text chunks to embed when\n                                  --selection-method=auto.  [default: 300]\n  --k INTEGER                     The maximum number of documents to select\n                                  from each centroid when --selection-\n                                  method=auto.  [default: 15]\n  --limit INTEGER                 The number of documents to load when\n                                  --selection-method={random,top}.  [default:\n                                  15]\n  --max-tokens INTEGER            The max token count for prompt generation.\n                                  [default: 2000]\n  --min-examples-required INTEGER\n                                  The minimum number of examples to\n                                  generate/include in the entity extraction\n                                  prompt.  [default: 2]\n  --chunk-size INTEGER            The max token count for prompt generation.\n                                  [default: 200]\n  --language TEXT                 The primary language used for inputs and\n                                  outputs in graphrag prompts.\n  --discover-entity-types / --no-discover-entity-types\n                                  Discover and extract unspecified entity\n                                  types.  [default: discover-entity-types]\n  --output PATH                   The directory to save prompts to, relative\n                                  to the project root directory.  [default:\n                                  prompts]\n</code></pre>"}, {"location": "cli/#query", "title": "query", "text": "<p>Query a knowledge graph index.</p> <p>Usage:</p> <pre><code> query [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  --method [local|global]       The query algorithm to use.  [required]\n  --query TEXT                  The query to execute.  [required]\n  --config PATH                 The configuration to use.\n  --data PATH                   Indexing pipeline output directory (i.e.\n                                contains the parquet files).\n  --root PATH                   The project root directory.  [default: .]\n  --community-level INTEGER     The community level in the Leiden community\n                                hierarchy from which to load community\n                                reports. Higher values represent reports from\n                                smaller communities.  [default: 2]\n  --response-type TEXT          Free form text describing the response type\n                                and format, can be anything, e.g. Multiple\n                                Paragraphs, Single Paragraph, Single Sentence,\n                                List of 3-7 Points, Single Page, Multi-Page\n                                Report. Default: Multiple Paragraphs\n                                [default: Multiple Paragraphs]\n  --streaming / --no-streaming  Print response in a streaming manner.\n                                [default: no-streaming]\n</code></pre>"}, {"location": "developing/", "title": "Development Guide", "text": ""}, {"location": "developing/#requirements", "title": "Requirements", "text": "Name Installation Purpose Python 3.10-3.12 Download The library is Python-based. Poetry Instructions Poetry is used for package management and virtualenv management in Python codebases"}, {"location": "developing/#getting-started", "title": "Getting Started", "text": ""}, {"location": "developing/#install-dependencies", "title": "Install Dependencies", "text": "<pre><code># Install Python dependencies.\npoetry install\n</code></pre>"}, {"location": "developing/#execute-the-indexing-engine", "title": "Execute the Indexing Engine", "text": "<pre><code>poetry run poe index &lt;...args&gt;\n</code></pre>"}, {"location": "developing/#executing-queries", "title": "Executing Queries", "text": "<pre><code>poetry run poe query &lt;...args&gt;\n</code></pre>"}, {"location": "developing/#azurite", "title": "Azurite", "text": "<p>Some unit and smoke tests use Azurite to emulate Azure resources. This can be started by running:</p> <pre><code>./scripts/start-azurite.sh\n</code></pre> <p>or by simply running <code>azurite</code> in the terminal if already installed globally. See the Azurite documentation for more information about how to install and use Azurite.</p>"}, {"location": "developing/#lifecycle-scripts", "title": "Lifecycle Scripts", "text": "<p>Our Python package utilizes Poetry to manage dependencies and poethepoet to manage build scripts.</p> <p>Available scripts are:</p> <ul> <li><code>poetry run poe index</code> - Run the Indexing CLI</li> <li><code>poetry run poe query</code> - Run the Query CLI</li> <li><code>poetry build</code> - This invokes <code>poetry build</code>, which will build a wheel file and other distributable artifacts.</li> <li><code>poetry run poe test</code> - This will execute all tests.</li> <li><code>poetry run poe test_unit</code> - This will execute unit tests.</li> <li><code>poetry run poe test_integration</code> - This will execute integration tests.</li> <li><code>poetry run poe test_smoke</code> - This will execute smoke tests.</li> <li><code>poetry run poe check</code> - This will perform a suite of static checks across the package, including:</li> <li>formatting</li> <li>documentation formatting</li> <li>linting</li> <li>security patterns</li> <li>type-checking</li> <li><code>poetry run poe fix</code> - This will apply any available auto-fixes to the package. Usually this is just formatting fixes.</li> <li><code>poetry run poe fix_unsafe</code> - This will apply any available auto-fixes to the package, including those that may be unsafe.</li> <li><code>poetry run poe format</code> - Explicitly run the formatter across the package.</li> </ul>"}, {"location": "developing/#troubleshooting", "title": "Troubleshooting", "text": ""}, {"location": "developing/#runtimeerror-llvm-config-failed-executing-please-point-llvm_config-to-the-path-for-llvm-config-when-running-poetry-install", "title": "\"RuntimeError: llvm-config failed executing, please point LLVM_CONFIG to the path for llvm-config\" when running poetry install", "text": "<p>Make sure llvm-9 and llvm-9-dev are installed:</p> <p><code>sudo apt-get install llvm-9 llvm-9-dev</code></p> <p>and then in your bashrc, add</p> <p><code>export LLVM_CONFIG=/usr/bin/llvm-config-9</code></p>"}, {"location": "developing/#numba_pymoduleh610-fatal-error-pythonh-no-such-file-or-directory-when-running-poetry-install", "title": "\"numba/_pymodule.h:6:10: fatal error: Python.h: No such file or directory\" when running poetry install", "text": "<p>Make sure you have python3.10-dev installed or more generally <code>python&lt;version&gt;-dev</code></p> <p><code>sudo apt-get install python3.10-dev</code></p>"}, {"location": "developing/#llm-call-constantly-exceeds-tpm-rpm-or-time-limits", "title": "LLM call constantly exceeds TPM, RPM or time limits", "text": "<p><code>GRAPHRAG_LLM_THREAD_COUNT</code> and <code>GRAPHRAG_EMBEDDING_THREAD_COUNT</code> are both set to 50 by default. You can modify this values to reduce concurrency. Please refer to the Configuration Documents</p>"}, {"location": "get_started/", "title": "Getting Started", "text": ""}, {"location": "get_started/#requirements", "title": "Requirements", "text": "<p>Python 3.10-3.12</p> <p>To get started with the GraphRAG system, you have a few options:</p> <p>\ud83d\udc49 Use the GraphRAG Accelerator solution  \ud83d\udc49 Install from pypi.  \ud83d\udc49 Use it from source</p>"}, {"location": "get_started/#quickstart", "title": "Quickstart", "text": "<p>To get started with the GraphRAG system we recommend trying the Solution Accelerator package. This provides a user-friendly end-to-end experience with Azure resources.</p>"}, {"location": "get_started/#top-level-modules", "title": "Top-Level Modules", "text": "<ul> <li>Indexing Pipeline Overview</li> <li>Query Engine Overview</li> </ul>"}, {"location": "get_started/#overview", "title": "Overview", "text": "<p>The following is a simple end-to-end example for using the GraphRAG system. It shows how to use the system to index some text, and then use the indexed data to answer questions about the documents.</p>"}, {"location": "get_started/#install-graphrag", "title": "Install GraphRAG", "text": "<pre><code>pip install graphrag\n</code></pre> <p>The graphrag library includes a CLI for a no-code approach to getting started. Please review the full CLI documentation for further detail.</p>"}, {"location": "get_started/#running-the-indexer", "title": "Running the Indexer", "text": "<p>Now we need to set up a data project and some initial configuration. Let's set that up. We're using the default configuration mode, which you can customize as needed using a config file, which we recommend, or environment variables.</p> <p>First let's get a sample dataset ready:</p> <pre><code>mkdir -p ./ragtest/input\n</code></pre> <p>Now let's get a copy of A Christmas Carol by Charles Dickens from a trusted source</p> <pre><code>curl https://www.gutenberg.org/cache/epub/24022/pg24022.txt -o ./ragtest/input/book.txt\n</code></pre> <p>Next we'll inject some required config variables:</p>"}, {"location": "get_started/#set-up-your-workspace-variables", "title": "Set Up Your Workspace Variables", "text": "<p>First let's make sure to setup the required environment variables. For details on these environment variables, and what environment variables are available, see the variables documentation.</p> <p>To initialize your workspace, first run the <code>graphrag init</code> command. Since we have already configured a directory named <code>./ragtest</code> in the previous step, run the following command:</p> <pre><code>graphrag init --root ./ragtest\n</code></pre> <p>This will create two files: <code>.env</code> and <code>settings.yaml</code> in the <code>./ragtest</code> directory.</p> <ul> <li><code>.env</code> contains the environment variables required to run the GraphRAG pipeline. If you inspect the file, you'll see a single environment variable defined,   <code>GRAPHRAG_API_KEY=&lt;API_KEY&gt;</code>. This is the API key for the OpenAI API or Azure OpenAI endpoint. You can replace this with your own API key. If you are using another form of authentication (i.e. managed identity), please delete this file.</li> <li><code>settings.yaml</code> contains the settings for the pipeline. You can modify this file to change the settings for the pipeline.   </li> </ul>"}, {"location": "get_started/#openai-and-azure-openai", "title": "OpenAI and Azure OpenAI", "text": "<p>If running in OpenAI mode, update the value of <code>GRAPHRAG_API_KEY</code> in the <code>.env</code> file with your OpenAI API key.</p>"}, {"location": "get_started/#azure-openai", "title": "Azure OpenAI", "text": "<p>In addition, Azure OpenAI users should set the following variables in the settings.yaml file. To find the appropriate sections, just search for the <code>llm:</code> configuration, you should see two sections, one for the chat endpoint and one for the embeddings endpoint. Here is an example of how to configure the chat endpoint:</p> <pre><code>type: azure_openai_chat # Or azure_openai_embedding for embeddings\napi_base: https://&lt;instance&gt;.openai.azure.com\napi_version: 2024-02-15-preview # You can customize this for other versions\ndeployment_name: &lt;azure_model_deployment_name&gt;\n</code></pre> <ul> <li>For more details about configuring GraphRAG, see the configuration documentation.</li> <li>To learn more about Initialization, refer to the Initialization documentation.</li> <li>For more details about using the CLI, refer to the CLI documentation.</li> </ul>"}, {"location": "get_started/#running-the-indexing-pipeline", "title": "Running the Indexing pipeline", "text": "<p>Finally we'll run the pipeline!</p> <pre><code>graphrag index --root ./ragtest\n</code></pre> <p></p> <p>This process will take some time to run. This depends on the size of your input data, what model you're using, and the text chunk size being used (these can be configured in your <code>settings.yml</code> file). Once the pipeline is complete, you should see a new folder called <code>./ragtest/output</code> with a series of parquet files.</p>"}, {"location": "get_started/#using-the-query-engine", "title": "Using the Query Engine", "text": ""}, {"location": "get_started/#running-the-query-engine", "title": "Running the Query Engine", "text": "<p>Now let's ask some questions using this dataset.</p> <p>Here is an example using Global search to ask a high-level question:</p> <pre><code>graphrag query \\\n--root ./ragtest \\\n--method global \\\n--query \"What are the top themes in this story?\"\n</code></pre> <p>Here is an example using Local search to ask a more specific question about a particular character:</p> <pre><code>graphrag query \\\n--root ./ragtest \\\n--method local \\\n--query \"Who is Scrooge and what are his main relationships?\"\n</code></pre> <p>Please refer to Query Engine docs for detailed information about how to leverage our Local and Global search mechanisms for extracting meaningful insights from data after the Indexer has wrapped up execution.</p>"}, {"location": "config/custom/", "title": "Fully Custom Config", "text": "<p>The primary configuration sections for Indexing Engine pipelines are described below. Each configuration section can be expressed in Python (for use in Python API mode) as well as YAML, but YAML is show here for brevity.</p> <p>Using custom configuration is an advanced use-case. Most users will want to use the Default Configuration instead.</p>"}, {"location": "config/custom/#indexing-engine-examples", "title": "Indexing Engine Examples", "text": "<p>The examples directory contains several examples of how to use the indexing engine with custom configuration.</p> <p>Most examples include two different forms of running the pipeline, both are contained in the examples <code>run.py</code></p> <ol> <li>Using mostly the Python API</li> <li>Using mostly the a pipeline configuration file</li> </ol> <p>To run an example:</p> <ul> <li>Run <code>poetry shell</code> to activate a virtual environment with the required dependencies.</li> <li>Run <code>PYTHONPATH=\"$(pwd)\" python examples/path_to_example/run.py</code> from the <code>root</code> directory.</li> </ul> <p>For example to run the single_verb example, you would run the following commands:</p> <pre><code>poetry shell\n</code></pre> <pre><code>PYTHONPATH=\"$(pwd)\" python examples/single_verb/run.py\n</code></pre>"}, {"location": "config/custom/#configuration-sections", "title": "Configuration Sections", "text": ""}, {"location": "config/custom/#extends", "title": "&gt; extends", "text": "<p>This configuration allows you to extend a base configuration file or files.</p> <pre><code># single base\nextends: ../base_config.yml\n</code></pre> <pre><code># multiple bases\nextends:\n  - ../base_config.yml\n  - ../base_config2.yml\n</code></pre>"}, {"location": "config/custom/#root_dir", "title": "&gt; root_dir", "text": "<p>This configuration allows you to set the root directory for the pipeline. All data inputs and outputs are assumed to be relative to this path.</p> <pre><code>root_dir: /workspace/data_project\n</code></pre>"}, {"location": "config/custom/#storage", "title": "&gt; storage", "text": "<p>This configuration allows you define the output strategy for the pipeline.</p> <ul> <li><code>type</code>: The type of storage to use. Options are <code>file</code>, <code>memory</code>, and <code>blob</code></li> <li><code>base_dir</code> (<code>type: file</code> only): The base directory to store the data in. This is relative to the config root.</li> <li><code>connection_string</code> (<code>type: blob</code> only): The connection string to use for blob storage.</li> <li><code>container_name</code> (<code>type: blob</code> only): The container to use for blob storage.</li> </ul>"}, {"location": "config/custom/#cache", "title": "&gt; cache", "text": "<p>This configuration allows you define the cache strategy for the pipeline.</p> <ul> <li><code>type</code>: The type of cache to use. Options are <code>file</code> and <code>memory</code>, and <code>blob</code>.</li> <li><code>base_dir</code> (<code>type: file</code> only): The base directory to store the cache in. This is relative to the config root.</li> <li><code>connection_string</code> (<code>type: blob</code> only): The connection string to use for blob storage.</li> <li><code>container_name</code> (<code>type: blob</code> only): The container to use for blob storage.</li> </ul>"}, {"location": "config/custom/#reporting", "title": "&gt; reporting", "text": "<p>This configuration allows you define the reporting strategy for the pipeline. Report files are generated artifacts that summarize the performance metrics of the pipeline and emit any error messages.</p> <ul> <li><code>type</code>: The type of reporting to use. Options are <code>file</code>, <code>memory</code>, and <code>blob</code></li> <li><code>base_dir</code> (<code>type: file</code> only): The base directory to store the reports in. This is relative to the config root.</li> <li><code>connection_string</code> (<code>type: blob</code> only): The connection string to use for blob storage.</li> <li><code>container_name</code> (<code>type: blob</code> only): The container to use for blob storage.</li> </ul>"}, {"location": "config/custom/#workflows", "title": "&gt; workflows", "text": "<p>This configuration section defines the workflow DAG for the pipeline. Here we define an array of workflows and express their inter-dependencies in steps:</p> <ul> <li><code>name</code>: The name of the workflow. This is used to reference the workflow in other parts of the config.</li> <li><code>steps</code>: The DataShaper steps that this workflow comprises. If a step defines an input in the form of <code>workflow:&lt;workflow_name&gt;</code>, then it is assumed to have a dependency on the output of that workflow.</li> </ul> <pre><code>workflows:\n  - name: workflow1\n    steps:\n      - verb: derive\n        args:\n          column1: \"col1\"\n          column2: \"col2\"\n  - name: workflow2\n    steps:\n      - verb: derive\n        args:\n          column1: \"col1\"\n          column2: \"col2\"\n        input:\n          # dependency established here\n          source: workflow:workflow1\n</code></pre>"}, {"location": "config/custom/#input", "title": "&gt; input", "text": "<ul> <li><code>type</code>: The type of input to use. Options are <code>file</code> or <code>blob</code>.</li> <li><code>file_type</code>: The file type field discriminates between the different input types. Options are <code>csv</code> and <code>text</code>.</li> <li><code>base_dir</code>: The base directory to read the input files from. This is relative to the config file.</li> <li><code>file_pattern</code>: A regex to match the input files. The regex must have named groups for each of the fields in the file_filter.</li> <li><code>post_process</code>: A DataShaper workflow definition to apply to the input before executing the primary workflow.</li> <li><code>source_column</code> (<code>type: csv</code> only): The column containing the source/author of the data</li> <li><code>text_column</code> (<code>type: csv</code> only): The column containing the text of the data</li> <li><code>timestamp_column</code> (<code>type: csv</code> only): The column containing the timestamp of the data</li> <li><code>timestamp_format</code> (<code>type: csv</code> only): The format of the timestamp</li> </ul> <pre><code>input:\n  type: file\n  file_type: csv\n  base_dir: ../data/csv # the directory containing the CSV files, this is relative to the config file\n  file_pattern: '.*[\\/](?P&lt;source&gt;[^\\/]+)[\\/](?P&lt;year&gt;\\d{4})-(?P&lt;month&gt;\\d{2})-(?P&lt;day&gt;\\d{2})_(?P&lt;author&gt;[^_]+)_\\d+\\.csv$' # a regex to match the CSV files\n  # An additional file filter which uses the named groups from the file_pattern to further filter the files\n  # file_filter:\n  #   # source: (source_filter)\n  #   year: (2023)\n  #   month: (06)\n  #   # day: (22)\n  source_column: \"author\" # the column containing the source/author of the data\n  text_column: \"message\" # the column containing the text of the data\n  timestamp_column: \"date(yyyyMMddHHmmss)\" # optional, the column containing the timestamp of the data\n  timestamp_format: \"%Y%m%d%H%M%S\" # optional,  the format of the timestamp\n  post_process: # Optional, set of steps to process the data before going into the workflow\n    - verb: filter\n      args:\n        column: \"title\",\n        value: \"My document\"\n</code></pre> <pre><code>input:\n  type: file\n  file_type: csv\n  base_dir: ../data/csv # the directory containing the CSV files, this is relative to the config file\n  file_pattern: '.*[\\/](?P&lt;source&gt;[^\\/]+)[\\/](?P&lt;year&gt;\\d{4})-(?P&lt;month&gt;\\d{2})-(?P&lt;day&gt;\\d{2})_(?P&lt;author&gt;[^_]+)_\\d+\\.csv$' # a regex to match the CSV files\n  # An additional file filter which uses the named groups from the file_pattern to further filter the files\n  # file_filter:\n  #   # source: (source_filter)\n  #   year: (2023)\n  #   month: (06)\n  #   # day: (22)\n  post_process: # Optional, set of steps to process the data before going into the workflow\n    - verb: filter\n      args:\n        column: \"title\",\n        value: \"My document\"\n</code></pre>"}, {"location": "config/env_vars/", "title": "Default Configuration Mode (using Env Vars)", "text": ""}, {"location": "config/env_vars/#text-embeddings-customization", "title": "Text-Embeddings Customization", "text": "<p>By default, the GraphRAG indexer will only emit embeddings required for our query methods. However, the model has embeddings defined for all plaintext fields, and these can be generated by setting the <code>GRAPHRAG_EMBEDDING_TARGET</code> environment variable to <code>all</code>.</p> <p>If the embedding target is <code>all</code>, and you want to only embed a subset of these fields, you may specify which embeddings to skip using the <code>GRAPHRAG_EMBEDDING_SKIP</code> argument described below.</p>"}, {"location": "config/env_vars/#embedded-fields", "title": "Embedded Fields", "text": "<ul> <li><code>text_unit.text</code></li> <li><code>document.raw_content</code></li> <li><code>entity.name</code></li> <li><code>entity.description</code></li> <li><code>relationship.description</code></li> <li><code>community.title</code></li> <li><code>community.summary</code></li> <li><code>community.full_content</code></li> </ul>"}, {"location": "config/env_vars/#input-data", "title": "Input Data", "text": "<p>Our pipeline can ingest .csv or .txt data from an input folder. These files can be nested within subfolders. To configure how input data is handled, what fields are mapped over, and how timestamps are parsed, look for configuration values starting with <code>GRAPHRAG_INPUT_</code> below. In general, CSV-based data provides the most customizability. Each CSV should at least contain a <code>text</code> field (which can be mapped with environment variables), but it's helpful if they also have <code>title</code>, <code>timestamp</code>, and <code>source</code> fields. Additional fields can be included as well, which will land as extra fields on the <code>Document</code> table.</p>"}, {"location": "config/env_vars/#base-llm-settings", "title": "Base LLM Settings", "text": "<p>These are the primary settings for configuring LLM connectivity.</p> Parameter Required? Description Type Default Value <code>GRAPHRAG_API_KEY</code> Yes for OpenAI. Optional for AOAI The API key. (Note: <code>OPENAI_API_KEY is also used as a fallback). If not defined when using AOAI, managed identity will be used. |</code>str<code>|</code>None` <code>GRAPHRAG_API_BASE</code> For AOAI The API Base URL <code>str</code> <code>None</code> <code>GRAPHRAG_API_VERSION</code> For AOAI The AOAI API version. <code>str</code> <code>None</code> <code>GRAPHRAG_API_ORGANIZATION</code> The AOAI organization. <code>str</code> <code>None</code> <code>GRAPHRAG_API_PROXY</code> The AOAI proxy. <code>str</code> <code>None</code>"}, {"location": "config/env_vars/#text-generation-settings", "title": "Text Generation Settings", "text": "<p>These settings control the text generation model used by the pipeline. Any settings with a fallback will use the base LLM settings, if available.</p> Parameter Required? Description Type Default Value <code>GRAPHRAG_LLM_TYPE</code> For AOAI The LLM operation type. Either <code>openai_chat</code> or <code>azure_openai_chat</code> <code>str</code> <code>openai_chat</code> <code>GRAPHRAG_LLM_DEPLOYMENT_NAME</code> For AOAI The AOAI model deployment name. <code>str</code> <code>None</code> <code>GRAPHRAG_LLM_API_KEY</code> Yes (uses fallback) The API key. If not defined when using AOAI, managed identity will be used. <code>str</code> <code>None</code> <code>GRAPHRAG_LLM_API_BASE</code> For AOAI (uses fallback) The API Base URL <code>str</code> <code>None</code> <code>GRAPHRAG_LLM_API_VERSION</code> For AOAI (uses fallback) The AOAI API version. <code>str</code> <code>None</code> <code>GRAPHRAG_LLM_API_ORGANIZATION</code> For AOAI (uses fallback) The AOAI organization. <code>str</code> <code>None</code> <code>GRAPHRAG_LLM_API_PROXY</code> The AOAI proxy. <code>str</code> <code>None</code> <code>GRAPHRAG_LLM_MODEL</code> The LLM model. <code>str</code> <code>gpt-4-turbo-preview</code> <code>GRAPHRAG_LLM_MAX_TOKENS</code> The maximum number of tokens. <code>int</code> <code>4000</code> <code>GRAPHRAG_LLM_REQUEST_TIMEOUT</code> The maximum number of seconds to wait for a response from the chat client. <code>int</code> <code>180</code> <code>GRAPHRAG_LLM_MODEL_SUPPORTS_JSON</code> Indicates whether the given model supports JSON output mode. <code>True</code> to enable. <code>str</code> <code>None</code> <code>GRAPHRAG_LLM_THREAD_COUNT</code> The number of threads to use for LLM parallelization. <code>int</code> 50 <code>GRAPHRAG_LLM_THREAD_STAGGER</code> The time to wait (in seconds) between starting each thread. <code>float</code> 0.3 <code>GRAPHRAG_LLM_CONCURRENT_REQUESTS</code> The number of concurrent requests to allow for the embedding client. <code>int</code> 25 <code>GRAPHRAG_LLM_TOKENS_PER_MINUTE</code> The number of tokens per minute to allow for the LLM client. 0 = Bypass <code>int</code> 0 <code>GRAPHRAG_LLM_REQUESTS_PER_MINUTE</code> The number of requests per minute to allow for the LLM client. 0 = Bypass <code>int</code> 0 <code>GRAPHRAG_LLM_MAX_RETRIES</code> The maximum number of retries to attempt when a request fails. <code>int</code> 10 <code>GRAPHRAG_LLM_MAX_RETRY_WAIT</code> The maximum number of seconds to wait between retries. <code>int</code> 10 <code>GRAPHRAG_LLM_SLEEP_ON_RATE_LIMIT_RECOMMENDATION</code> Whether to sleep on rate limit recommendation. (Azure Only) <code>bool</code> <code>True</code> <code>GRAPHRAG_LLM_TEMPERATURE</code> The temperature to use generation. <code>float</code> 0 <code>GRAPHRAG_LLM_TOP_P</code> The top_p to use for sampling. <code>float</code> 1 <code>GRAPHRAG_LLM_N</code> The number of responses to generate. <code>int</code> 1"}, {"location": "config/env_vars/#text-embedding-settings", "title": "Text Embedding Settings", "text": "<p>These settings control the text embedding model used by the pipeline. Any settings with a fallback will use the base LLM settings, if available.</p> Parameter Required ? Description Type Default <code>GRAPHRAG_EMBEDDING_TYPE</code> For AOAI The embedding client to use. Either <code>openai_embedding</code> or <code>azure_openai_embedding</code> <code>str</code> <code>openai_embedding</code> <code>GRAPHRAG_EMBEDDING_DEPLOYMENT_NAME</code> For AOAI The AOAI deployment name. <code>str</code> <code>None</code> <code>GRAPHRAG_EMBEDDING_API_KEY</code> Yes (uses fallback) The API key to use for the embedding client. If not defined when using AOAI, managed identity will be used. <code>str</code> <code>None</code> <code>GRAPHRAG_EMBEDDING_API_BASE</code> For AOAI (uses fallback) The API base URL. <code>str</code> <code>None</code> <code>GRAPHRAG_EMBEDDING_API_VERSION</code> For AOAI (uses fallback) The AOAI API version to use for the embedding client. <code>str</code> <code>None</code> <code>GRAPHRAG_EMBEDDING_API_ORGANIZATION</code> For AOAI (uses fallback) The AOAI organization to use for the embedding client. <code>str</code> <code>None</code> <code>GRAPHRAG_EMBEDDING_API_PROXY</code> The AOAI proxy to use for the embedding client. <code>str</code> <code>None</code> <code>GRAPHRAG_EMBEDDING_MODEL</code> The model to use for the embedding client. <code>str</code> <code>text-embedding-3-small</code> <code>GRAPHRAG_EMBEDDING_BATCH_SIZE</code> The number of texts to embed at once. (Azure limit is 16) <code>int</code> 16 <code>GRAPHRAG_EMBEDDING_BATCH_MAX_TOKENS</code> The maximum tokens per batch (Azure limit is 8191) <code>int</code> 8191 <code>GRAPHRAG_EMBEDDING_TARGET</code> The target fields to embed. Either <code>required</code> or <code>all</code>. <code>str</code> <code>required</code> <code>GRAPHRAG_EMBEDDING_SKIP</code> A comma-separated list of fields to skip embeddings for . (e.g. 'relationship.description') <code>str</code> <code>None</code> <code>GRAPHRAG_EMBEDDING_THREAD_COUNT</code> The number of threads to use for parallelization for embeddings. <code>int</code> <code>GRAPHRAG_EMBEDDING_THREAD_STAGGER</code> The time to wait (in seconds) between starting each thread for embeddings. <code>float</code> 50 <code>GRAPHRAG_EMBEDDING_CONCURRENT_REQUESTS</code> The number of concurrent requests to allow for the embedding client. <code>int</code> 25 <code>GRAPHRAG_EMBEDDING_TOKENS_PER_MINUTE</code> The number of tokens per minute to allow for the embedding client. 0 = Bypass <code>int</code> 0 <code>GRAPHRAG_EMBEDDING_REQUESTS_PER_MINUTE</code> The number of requests per minute to allow for the embedding client. 0 = Bypass <code>int</code> 0 <code>GRAPHRAG_EMBEDDING_MAX_RETRIES</code> The maximum number of retries to attempt when a request fails. <code>int</code> 10 <code>GRAPHRAG_EMBEDDING_MAX_RETRY_WAIT</code> The maximum number of seconds to wait between retries. <code>int</code> 10 <code>GRAPHRAG_EMBEDDING_SLEEP_ON_RATE_LIMIT_RECOMMENDATION</code> Whether to sleep on rate limit recommendation. (Azure Only) <code>bool</code> <code>True</code>"}, {"location": "config/env_vars/#input-settings", "title": "Input Settings", "text": "<p>These settings control the data input used by the pipeline. Any settings with a fallback will use the base LLM settings, if available.</p>"}, {"location": "config/env_vars/#plaintext-input-data-graphrag_input_file_typetext", "title": "Plaintext Input Data (<code>GRAPHRAG_INPUT_FILE_TYPE</code>=text)", "text": "Parameter Description Type Required or Optional Default <code>GRAPHRAG_INPUT_FILE_PATTERN</code> The file pattern regexp to use when reading input files from the input directory. <code>str</code> optional <code>.*\\.txt$</code>"}, {"location": "config/env_vars/#csv-input-data-graphrag_input_file_typecsv", "title": "CSV Input Data (<code>GRAPHRAG_INPUT_FILE_TYPE</code>=csv)", "text": "Parameter Description Type Required or Optional Default <code>GRAPHRAG_INPUT_TYPE</code> The input storage type to use when reading files. (<code>file</code> or <code>blob</code>) <code>str</code> optional <code>file</code> <code>GRAPHRAG_INPUT_FILE_PATTERN</code> The file pattern regexp to use when reading input files from the input directory. <code>str</code> optional <code>.*\\.txt$</code> <code>GRAPHRAG_INPUT_SOURCE_COLUMN</code> The 'source' column to use when reading CSV input files. <code>str</code> optional <code>source</code> <code>GRAPHRAG_INPUT_TIMESTAMP_COLUMN</code> The 'timestamp' column to use when reading CSV input files. <code>str</code> optional <code>None</code> <code>GRAPHRAG_INPUT_TIMESTAMP_FORMAT</code> The timestamp format to use when parsing timestamps in the timestamp column. <code>str</code> optional <code>None</code> <code>GRAPHRAG_INPUT_TEXT_COLUMN</code> The 'text' column to use when reading CSV input files. <code>str</code> optional <code>text</code> <code>GRAPHRAG_INPUT_DOCUMENT_ATTRIBUTE_COLUMNS</code> A list of CSV columns, comma-separated, to incorporate as document fields. <code>str</code> optional <code>id</code> <code>GRAPHRAG_INPUT_TITLE_COLUMN</code> The 'title' column to use when reading CSV input files. <code>str</code> optional <code>title</code> <code>GRAPHRAG_INPUT_STORAGE_ACCOUNT_BLOB_URL</code> The Azure Storage blob endpoint to use when in <code>blob</code> mode and using managed identity. Will have the format <code>https://&lt;storage_account_name&gt;.blob.core.windows.net</code> <code>str</code> optional <code>None</code> <code>GRAPHRAG_INPUT_CONNECTION_STRING</code> The connection string to use when reading CSV input files from Azure Blob Storage. <code>str</code> optional <code>None</code> <code>GRAPHRAG_INPUT_CONTAINER_NAME</code> The container name to use when reading CSV input files from Azure Blob Storage. <code>str</code> optional <code>None</code> <code>GRAPHRAG_INPUT_BASE_DIR</code> The base directory to read input files from. <code>str</code> optional <code>None</code>"}, {"location": "config/env_vars/#data-mapping-settings", "title": "Data Mapping Settings", "text": "Parameter Description Type Required or Optional Default <code>GRAPHRAG_INPUT_FILE_TYPE</code> The type of input data, <code>csv</code> or <code>text</code> <code>str</code> optional <code>text</code> <code>GRAPHRAG_INPUT_ENCODING</code> The encoding to apply when reading CSV/text input files. <code>str</code> optional <code>utf-8</code>"}, {"location": "config/env_vars/#data-chunking", "title": "Data Chunking", "text": "Parameter Description Type Required or Optional Default <code>GRAPHRAG_CHUNK_SIZE</code> The chunk size in tokens for text-chunk analysis windows. <code>str</code> optional 1200 <code>GRAPHRAG_CHUNK_OVERLAP</code> The chunk overlap in tokens for text-chunk analysis windows. <code>str</code> optional 100 <code>GRAPHRAG_CHUNK_BY_COLUMNS</code> A comma-separated list of document attributes to groupby when performing TextUnit chunking. <code>str</code> optional <code>id</code> <code>GRAPHRAG_CHUNK_ENCODING_MODEL</code> The encoding model to use for chunking. <code>str</code> optional The top-level encoding model."}, {"location": "config/env_vars/#prompting-overrides", "title": "Prompting Overrides", "text": "Parameter Description Type Required or Optional Default <code>GRAPHRAG_ENTITY_EXTRACTION_PROMPT_FILE</code> The path (relative to the root) of an entity extraction prompt template text file. <code>str</code> optional <code>None</code> <code>GRAPHRAG_ENTITY_EXTRACTION_MAX_GLEANINGS</code> The maximum number of redrives (gleanings) to invoke when extracting entities in a loop. <code>int</code> optional 1 <code>GRAPHRAG_ENTITY_EXTRACTION_ENTITY_TYPES</code> A comma-separated list of entity types to extract. <code>str</code> optional <code>organization,person,event,geo</code> <code>GRAPHRAG_ENTITY_EXTRACTION_ENCODING_MODEL</code> The encoding model to use for entity extraction. <code>str</code> optional The top-level encoding model. <code>GRAPHRAG_SUMMARIZE_DESCRIPTIONS_PROMPT_FILE</code> The path (relative to the root) of an description summarization prompt template text file. <code>str</code> optional <code>None</code> <code>GRAPHRAG_SUMMARIZE_DESCRIPTIONS_MAX_LENGTH</code> The maximum number of tokens to generate per description summarization. <code>int</code> optional 500 <code>GRAPHRAG_CLAIM_EXTRACTION_ENABLED</code> Whether claim extraction is enabled for this pipeline. <code>bool</code> optional <code>False</code> <code>GRAPHRAG_CLAIM_EXTRACTION_DESCRIPTION</code> The claim_description prompting argument to utilize. <code>string</code> optional \"Any claims or facts that could be relevant to threat analysis.\" <code>GRAPHRAG_CLAIM_EXTRACTION_PROMPT_FILE</code> The claim extraction prompt to utilize. <code>string</code> optional <code>None</code> <code>GRAPHRAG_CLAIM_EXTRACTION_MAX_GLEANINGS</code> The maximum number of redrives (gleanings) to invoke when extracting claims in a loop. <code>int</code> optional 1 <code>GRAPHRAG_CLAIM_EXTRACTION_ENCODING_MODEL</code> The encoding model to use for claim extraction. <code>str</code> optional The top-level encoding model <code>GRAPHRAG_COMMUNITY_REPORTS_PROMPT_FILE</code> The community reports extraction prompt to utilize. <code>string</code> optional <code>None</code> <code>GRAPHRAG_COMMUNITY_REPORTS_MAX_LENGTH</code> The maximum number of tokens to generate per community reports. <code>int</code> optional 1500"}, {"location": "config/env_vars/#storage", "title": "Storage", "text": "<p>This section controls the storage mechanism used by the pipeline used for emitting output tables.</p> Parameter Description Type Required or Optional Default <code>GRAPHRAG_STORAGE_TYPE</code> The type of reporter to use. Options are <code>file</code>, <code>memory</code>, or <code>blob</code> <code>str</code> optional <code>file</code> <code>GRAPHRAG_STORAGE_STORAGE_ACCOUNT_BLOB_URL</code> The Azure Storage blob endpoint to use when in <code>blob</code> mode and using managed identity. Will have the format <code>https://&lt;storage_account_name&gt;.blob.core.windows.net</code> <code>str</code> optional None <code>GRAPHRAG_STORAGE_CONNECTION_STRING</code> The Azure Storage connection string to use when in <code>blob</code> mode. <code>str</code> optional None <code>GRAPHRAG_STORAGE_CONTAINER_NAME</code> The Azure Storage container name to use when in <code>blob</code> mode. <code>str</code> optional None <code>GRAPHRAG_STORAGE_BASE_DIR</code> The base path to data outputs outputs. <code>str</code> optional None"}, {"location": "config/env_vars/#cache", "title": "Cache", "text": "<p>This section controls the cache mechanism used by the pipeline. This is used to cache LLM invocation results.</p> Parameter Description Type Required or Optional Default <code>GRAPHRAG_CACHE_TYPE</code> The type of cache to use. Options are <code>file</code>, <code>memory</code>, <code>none</code> or <code>blob</code> <code>str</code> optional <code>file</code> <code>GRAPHRAG_CACHE_STORAGE_ACCOUNT_BLOB_URL</code> The Azure Storage blob endpoint to use when in <code>blob</code> mode and using managed identity. Will have the format <code>https://&lt;storage_account_name&gt;.blob.core.windows.net</code> <code>str</code> optional None <code>GRAPHRAG_CACHE_CONNECTION_STRING</code> The Azure Storage connection string to use when in <code>blob</code> mode. <code>str</code> optional None <code>GRAPHRAG_CACHE_CONTAINER_NAME</code> The Azure Storage container name to use when in <code>blob</code> mode. <code>str</code> optional None <code>GRAPHRAG_CACHE_BASE_DIR</code> The base path to the cache files. <code>str</code> optional None"}, {"location": "config/env_vars/#reporting", "title": "Reporting", "text": "<p>This section controls the reporting mechanism used by the pipeline, for common events and error messages. The default is to write reports to a file in the output directory. However, you can also choose to write reports to the console or to an Azure Blob Storage container.</p> Parameter Description Type Required or Optional Default <code>GRAPHRAG_REPORTING_TYPE</code> The type of reporter to use. Options are <code>file</code>, <code>console</code>, or <code>blob</code> <code>str</code> optional <code>file</code> <code>GRAPHRAG_REPORTING_STORAGE_ACCOUNT_BLOB_URL</code> The Azure Storage blob endpoint to use when in <code>blob</code> mode and using managed identity. Will have the format <code>https://&lt;storage_account_name&gt;.blob.core.windows.net</code> <code>str</code> optional None <code>GRAPHRAG_REPORTING_CONNECTION_STRING</code> The Azure Storage connection string to use when in <code>blob</code> mode. <code>str</code> optional None <code>GRAPHRAG_REPORTING_CONTAINER_NAME</code> The Azure Storage container name to use when in <code>blob</code> mode. <code>str</code> optional None <code>GRAPHRAG_REPORTING_BASE_DIR</code> The base path to the reporting outputs. <code>str</code> optional None"}, {"location": "config/env_vars/#node2vec-parameters", "title": "Node2Vec Parameters", "text": "Parameter Description Type Required or Optional Default <code>GRAPHRAG_NODE2VEC_ENABLED</code> Whether to enable Node2Vec <code>bool</code> optional False <code>GRAPHRAG_NODE2VEC_NUM_WALKS</code> The Node2Vec number of walks to perform <code>int</code> optional 10 <code>GRAPHRAG_NODE2VEC_WALK_LENGTH</code> The Node2Vec walk length <code>int</code> optional 40 <code>GRAPHRAG_NODE2VEC_WINDOW_SIZE</code> The Node2Vec window size <code>int</code> optional 2 <code>GRAPHRAG_NODE2VEC_ITERATIONS</code> The number of iterations to run node2vec <code>int</code> optional 3 <code>GRAPHRAG_NODE2VEC_RANDOM_SEED</code> The random seed to use for node2vec <code>int</code> optional 597832"}, {"location": "config/env_vars/#data-snapshotting", "title": "Data Snapshotting", "text": "Parameter Description Type Required or Optional Default <code>GRAPHRAG_SNAPSHOT_GRAPHML</code> Whether to enable GraphML snapshots. <code>bool</code> optional False <code>GRAPHRAG_SNAPSHOT_RAW_ENTITIES</code> Whether to enable raw entity snapshots. <code>bool</code> optional False <code>GRAPHRAG_SNAPSHOT_TOP_LEVEL_NODES</code> Whether to enable top-level node snapshots. <code>bool</code> optional False"}, {"location": "config/env_vars/#miscellaneous-settings", "title": "Miscellaneous Settings", "text": "Parameter Description Type Required or Optional Default <code>GRAPHRAG_ASYNC_MODE</code> Which async mode to use. Either <code>asyncio</code> or <code>threaded</code>. <code>str</code> optional <code>asyncio</code> <code>GRAPHRAG_ENCODING_MODEL</code> The text encoding model, used in tiktoken, to encode text. <code>str</code> optional <code>cl100k_base</code> <code>GRAPHRAG_MAX_CLUSTER_SIZE</code> The maximum number of entities to include in a single Leiden cluster. <code>int</code> optional 10 <code>GRAPHRAG_SKIP_WORKFLOWS</code> A comma-separated list of workflow names to skip. <code>str</code> optional <code>None</code> <code>GRAPHRAG_UMAP_ENABLED</code> Whether to enable UMAP layouts <code>bool</code> optional False"}, {"location": "config/init/", "title": "Configuring GraphRAG Indexing", "text": "<p>To start using GraphRAG, you must generate a configuration file. The <code>init</code> command is the easiest way to get started. It will create a <code>.env</code> and <code>settings.yaml</code> files in the specified directory with the necessary configuration settings. It will also output the default LLM prompts used by GraphRAG.</p>"}, {"location": "config/init/#usage", "title": "Usage", "text": "<pre><code>graphrag init [--root PATH]\n</code></pre>"}, {"location": "config/init/#options", "title": "Options", "text": "<ul> <li><code>--root PATH</code> - The project root directory to initialize graphrag at. Default is the current directory.</li> </ul>"}, {"location": "config/init/#example", "title": "Example", "text": "<pre><code>graphrag init --root ./ragtest\n</code></pre>"}, {"location": "config/init/#output", "title": "Output", "text": "<p>The <code>init</code> command will create the following files in the specified directory:</p> <ul> <li><code>settings.yaml</code> - The configuration settings file. This file contains the configuration settings for GraphRAG.</li> <li><code>.env</code> - The environment variables file. These are referenced in the <code>settings.yaml</code> file.</li> <li><code>prompts/</code> - The LLM prompts folder. This contains the default prompts used by GraphRAG, you can modify them or run the Auto Prompt Tuning command to generate new prompts adapted to your data.</li> </ul>"}, {"location": "config/init/#next-steps", "title": "Next Steps", "text": "<p>After initializing your workspace, you can either run the Prompt Tuning command to adapt the prompts to your data or even start running the Indexing Pipeline to index your data. For more information on configuring GraphRAG, see the Configuration documentation.</p>"}, {"location": "config/json_yaml/", "title": "Default Configuration Mode (using JSON/YAML)", "text": "<p>The default configuration mode may be configured by using a <code>settings.json</code> or <code>settings.yml</code> file in the data project root. If a <code>.env</code> file is present along with this config file, then it will be loaded, and the environment variables defined therein will be available for token replacements in your configuration document using <code>${ENV_VAR}</code> syntax.</p> <p>For example:</p> <pre><code># .env\nAPI_KEY=some_api_key\n\n# settings.json\n{\n    \"llm\": {\n        \"api_key\": \"${API_KEY}\"\n    }\n}\n</code></pre>"}, {"location": "config/json_yaml/#config-sections", "title": "Config Sections", "text": ""}, {"location": "config/json_yaml/#input", "title": "input", "text": ""}, {"location": "config/json_yaml/#fields", "title": "Fields", "text": "<ul> <li><code>type</code> file|blob - The input type to use. Default=<code>file</code></li> <li><code>file_type</code> text|csv - The type of input data to load. Either <code>text</code> or <code>csv</code>. Default is <code>text</code></li> <li><code>file_encoding</code> str - The encoding of the input file. Default is <code>utf-8</code></li> <li><code>file_pattern</code> str - A regex to match input files. Default is <code>.*\\.csv$</code> if in csv mode and <code>.*\\.txt$</code> if in text mode.</li> <li><code>source_column</code> str - (CSV Mode Only) The source column name.</li> <li><code>timestamp_column</code> str - (CSV Mode Only) The timestamp column name.</li> <li><code>timestamp_format</code> str - (CSV Mode Only) The source format.</li> <li><code>text_column</code> str - (CSV Mode Only) The text column name.</li> <li><code>title_column</code> str - (CSV Mode Only) The title column name.</li> <li><code>document_attribute_columns</code> list[str] - (CSV Mode Only) The additional document attributes to include.</li> <li><code>connection_string</code> str - (blob only) The Azure Storage connection string.</li> <li><code>container_name</code> str - (blob only) The Azure Storage container name.</li> <li><code>base_dir</code> str - The base directory to read input from, relative to the root.</li> <li><code>storage_account_blob_url</code> str - The storage account blob URL to use.</li> </ul>"}, {"location": "config/json_yaml/#llm", "title": "llm", "text": "<p>This is the base LLM configuration section. Other steps may override this configuration with their own LLM configuration.</p>"}, {"location": "config/json_yaml/#fields_1", "title": "Fields", "text": "<ul> <li><code>api_key</code> str - The OpenAI API key to use.</li> <li><code>type</code> openai_chat|azure_openai_chat|openai_embedding|azure_openai_embedding - The type of LLM to use.</li> <li><code>model</code> str - The model name.</li> <li><code>max_tokens</code> int - The maximum number of output tokens.</li> <li><code>request_timeout</code> float - The per-request timeout.</li> <li><code>api_base</code> str - The API base url to use.</li> <li><code>api_version</code> str - The API version</li> <li><code>organization</code> str - The client organization.</li> <li><code>proxy</code> str - The proxy URL to use.</li> <li><code>audience</code> str - (Azure OpenAI only) The URI of the target Azure resource/service for which a managed identity token is requested. Used if <code>api_key</code> is not defined. Default=<code>https://cognitiveservices.azure.com/.default</code></li> <li><code>deployment_name</code> str - The deployment name to use (Azure).</li> <li><code>model_supports_json</code> bool - Whether the model supports JSON-mode output.</li> <li><code>tokens_per_minute</code> int - Set a leaky-bucket throttle on tokens-per-minute.</li> <li><code>requests_per_minute</code> int - Set a leaky-bucket throttle on requests-per-minute.</li> <li><code>max_retries</code> int - The maximum number of retries to use.</li> <li><code>max_retry_wait</code> float - The maximum backoff time.</li> <li><code>sleep_on_rate_limit_recommendation</code> bool - Whether to adhere to sleep recommendations (Azure).</li> <li><code>concurrent_requests</code> int The number of open requests to allow at once.</li> <li><code>temperature</code> float - The temperature to use.</li> <li><code>top_p</code> float - The top-p value to use.</li> <li><code>n</code> int - The number of completions to generate.</li> </ul>"}, {"location": "config/json_yaml/#parallelization", "title": "parallelization", "text": ""}, {"location": "config/json_yaml/#fields_2", "title": "Fields", "text": "<ul> <li><code>stagger</code> float - The threading stagger value.</li> <li><code>num_threads</code> int - The maximum number of work threads.</li> </ul>"}, {"location": "config/json_yaml/#async_mode", "title": "async_mode", "text": "<p>asyncio|threaded The async mode to use. Either <code>asyncio</code> or `threaded.</p>"}, {"location": "config/json_yaml/#embeddings", "title": "embeddings", "text": ""}, {"location": "config/json_yaml/#fields_3", "title": "Fields", "text": "<ul> <li><code>llm</code> (see LLM top-level config)</li> <li><code>parallelization</code> (see Parallelization top-level config)</li> <li><code>async_mode</code> (see Async Mode top-level config)</li> <li><code>batch_size</code> int - The maximum batch size to use.</li> <li><code>batch_max_tokens</code> int - The maximum batch # of tokens.</li> <li><code>target</code> required|all - Determines which set of embeddings to emit.</li> <li><code>skip</code> list[str] - Which embeddings to skip.</li> <li><code>vector_store</code> dict - The vector store to use. Configured for lancedb by default.</li> <li><code>type</code> str - <code>lancedb</code> or <code>azure_ai_search</code>. Default=<code>lancedb</code></li> <li><code>db_uri</code> str (only for lancedb) - The database uri. Default=<code>storage.base_dir/lancedb</code></li> <li><code>url</code> str (only for AI Search) - AI Search endpoint</li> <li><code>api_key</code> str (optional - only for AI Search) - The AI Search api key to use.</li> <li><code>audience</code> str (only for AI Search) - Audience for managed identity token if managed identity authentication is used.</li> <li><code>overwrite</code> bool (only used at index creation time) - Overwrite collection if it exist. Default=<code>True</code></li> <li><code>collection_name</code> str - The name of a vector collection. Default=<code>entity_description_embeddings</code></li> <li><code>strategy</code> dict - Fully override the text-embedding strategy.</li> </ul>"}, {"location": "config/json_yaml/#chunks", "title": "chunks", "text": ""}, {"location": "config/json_yaml/#fields_4", "title": "Fields", "text": "<ul> <li><code>size</code> int - The max chunk size in tokens.</li> <li><code>overlap</code> int - The chunk overlap in tokens.</li> <li><code>group_by_columns</code> list[str] - group documents by fields before chunking.</li> <li><code>encoding_model</code> str - The text encoding model to use. Default is to use the top-level encoding model.</li> <li><code>strategy</code> dict - Fully override the chunking strategy.</li> </ul>"}, {"location": "config/json_yaml/#cache", "title": "cache", "text": ""}, {"location": "config/json_yaml/#fields_5", "title": "Fields", "text": "<ul> <li><code>type</code> file|memory|none|blob - The cache type to use. Default=<code>file</code></li> <li><code>connection_string</code> str - (blob only) The Azure Storage connection string.</li> <li><code>container_name</code> str - (blob only) The Azure Storage container name.</li> <li><code>base_dir</code> str - The base directory to write cache to, relative to the root.</li> <li><code>storage_account_blob_url</code> str - The storage account blob URL to use.</li> </ul>"}, {"location": "config/json_yaml/#storage", "title": "storage", "text": ""}, {"location": "config/json_yaml/#fields_6", "title": "Fields", "text": "<ul> <li><code>type</code> file|memory|blob - The storage type to use. Default=<code>file</code></li> <li><code>connection_string</code> str - (blob only) The Azure Storage connection string.</li> <li><code>container_name</code> str - (blob only) The Azure Storage container name.</li> <li><code>base_dir</code> str - The base directory to write reports to, relative to the root.</li> <li><code>storage_account_blob_url</code> str - The storage account blob URL to use.</li> </ul>"}, {"location": "config/json_yaml/#reporting", "title": "reporting", "text": ""}, {"location": "config/json_yaml/#fields_7", "title": "Fields", "text": "<ul> <li><code>type</code> file|console|blob - The reporting type to use. Default=<code>file</code></li> <li><code>connection_string</code> str - (blob only) The Azure Storage connection string.</li> <li><code>container_name</code> str - (blob only) The Azure Storage container name.</li> <li><code>base_dir</code> str - The base directory to write reports to, relative to the root.</li> <li><code>storage_account_blob_url</code> str - The storage account blob URL to use.</li> </ul>"}, {"location": "config/json_yaml/#entity_extraction", "title": "entity_extraction", "text": ""}, {"location": "config/json_yaml/#fields_8", "title": "Fields", "text": "<ul> <li><code>llm</code> (see LLM top-level config)</li> <li><code>parallelization</code> (see Parallelization top-level config)</li> <li><code>async_mode</code> (see Async Mode top-level config)</li> <li><code>prompt</code> str - The prompt file to use.</li> <li><code>entity_types</code> list[str] - The entity types to identify.</li> <li><code>max_gleanings</code> int - The maximum number of gleaning cycles to use.</li> <li><code>encoding_model</code> str - The text encoding model to use. By default, this will use the top-level encoding model.</li> <li><code>strategy</code> dict - Fully override the entity extraction strategy.</li> </ul>"}, {"location": "config/json_yaml/#summarize_descriptions", "title": "summarize_descriptions", "text": ""}, {"location": "config/json_yaml/#fields_9", "title": "Fields", "text": "<ul> <li><code>llm</code> (see LLM top-level config)</li> <li><code>parallelization</code> (see Parallelization top-level config)</li> <li><code>async_mode</code> (see Async Mode top-level config)</li> <li><code>prompt</code> str - The prompt file to use.</li> <li><code>max_length</code> int - The maximum number of output tokens per summarization.</li> <li><code>strategy</code> dict - Fully override the summarize description strategy.</li> </ul>"}, {"location": "config/json_yaml/#claim_extraction", "title": "claim_extraction", "text": ""}, {"location": "config/json_yaml/#fields_10", "title": "Fields", "text": "<ul> <li><code>enabled</code> bool - Whether to enable claim extraction. default=False</li> <li><code>llm</code> (see LLM top-level config)</li> <li><code>parallelization</code> (see Parallelization top-level config)</li> <li><code>async_mode</code> (see Async Mode top-level config)</li> <li><code>prompt</code> str - The prompt file to use.</li> <li><code>description</code> str - Describes the types of claims we want to extract.</li> <li><code>max_gleanings</code> int - The maximum number of gleaning cycles to use.</li> <li><code>encoding_model</code> str - The text encoding model to use. By default, this will use the top-level encoding model.</li> <li><code>strategy</code> dict - Fully override the claim extraction strategy.</li> </ul>"}, {"location": "config/json_yaml/#community_reports", "title": "community_reports", "text": ""}, {"location": "config/json_yaml/#fields_11", "title": "Fields", "text": "<ul> <li><code>llm</code> (see LLM top-level config)</li> <li><code>parallelization</code> (see Parallelization top-level config)</li> <li><code>async_mode</code> (see Async Mode top-level config)</li> <li><code>prompt</code> str - The prompt file to use.</li> <li><code>max_length</code> int - The maximum number of output tokens per report.</li> <li><code>max_input_length</code> int - The maximum number of input tokens to use when generating reports.</li> <li><code>strategy</code> dict - Fully override the community reports strategy.</li> </ul>"}, {"location": "config/json_yaml/#cluster_graph", "title": "cluster_graph", "text": ""}, {"location": "config/json_yaml/#fields_12", "title": "Fields", "text": "<ul> <li><code>max_cluster_size</code> int - The maximum cluster size to emit.</li> <li><code>strategy</code> dict - Fully override the cluster_graph strategy.</li> </ul>"}, {"location": "config/json_yaml/#embed_graph", "title": "embed_graph", "text": ""}, {"location": "config/json_yaml/#fields_13", "title": "Fields", "text": "<ul> <li><code>enabled</code> bool - Whether to enable graph embeddings.</li> <li><code>num_walks</code> int - The node2vec number of walks.</li> <li><code>walk_length</code> int - The node2vec walk length.</li> <li><code>window_size</code> int - The node2vec window size.</li> <li><code>iterations</code> int - The node2vec number of iterations.</li> <li><code>random_seed</code> int - The node2vec random seed.</li> <li><code>strategy</code> dict - Fully override the embed graph strategy.</li> </ul>"}, {"location": "config/json_yaml/#umap", "title": "umap", "text": ""}, {"location": "config/json_yaml/#fields_14", "title": "Fields", "text": "<ul> <li><code>enabled</code> bool - Whether to enable UMAP layouts.</li> </ul>"}, {"location": "config/json_yaml/#snapshots", "title": "snapshots", "text": ""}, {"location": "config/json_yaml/#fields_15", "title": "Fields", "text": "<ul> <li><code>graphml</code> bool - Emit graphml snapshots.</li> <li><code>raw_entities</code> bool - Emit raw entity snapshots.</li> <li><code>top_level_nodes</code> bool - Emit top-level-node snapshots.</li> </ul>"}, {"location": "config/json_yaml/#encoding_model", "title": "encoding_model", "text": "<p>str - The text encoding model to use. Default=<code>cl100k_base</code>.</p>"}, {"location": "config/json_yaml/#skip_workflows", "title": "skip_workflows", "text": "<p>list[str] - Which workflow names to skip.</p>"}, {"location": "config/overview/", "title": "Configuring GraphRAG Indexing", "text": "<p>The GraphRAG system is highly configurable. This page provides an overview of the configuration options available for the GraphRAG indexing engine.</p>"}, {"location": "config/overview/#default-configuration-mode", "title": "Default Configuration Mode", "text": "<p>The default configuration mode is the simplest way to get started with the GraphRAG system. It is designed to work out-of-the-box with minimal configuration. The primary configuration sections for the Indexing Engine pipelines are described below. The main ways to set up GraphRAG in Default Configuration mode are via:</p> <ul> <li>Init command (recommended)</li> <li>Purely using environment variables</li> <li>Using JSON or YAML for deeper control</li> </ul>"}, {"location": "config/overview/#custom-configuration-mode", "title": "Custom Configuration Mode", "text": "<p>Custom configuration mode is an advanced use-case. Most users will want to use the Default Configuration instead. The primary configuration sections for Indexing Engine pipelines are described below. Details about how to use custom configuration are available in the Custom Configuration Mode documentation.</p>"}, {"location": "config/template/", "title": "Configuration Template", "text": "<p>The following template can be used and stored as a <code>.env</code> in the the directory where you're are pointing the <code>--root</code> parameter on your Indexing Pipeline execution.</p> <p>For details about how to run the Indexing Pipeline, refer to the Index CLI documentation.</p>"}, {"location": "config/template/#env-file-template", "title": ".env File Template", "text": "<p>Required variables are uncommented. All the optional configuration can be turned on or off as needed.</p>"}, {"location": "config/template/#minimal-configuration", "title": "Minimal Configuration", "text": "<pre><code># Base LLM Settings\nGRAPHRAG_API_KEY=\"your_api_key\"\nGRAPHRAG_API_BASE=\"http://&lt;domain&gt;.openai.azure.com\" # For Azure OpenAI Users\nGRAPHRAG_API_VERSION=\"api_version\" # For Azure OpenAI Users\n\n# Text Generation Settings\nGRAPHRAG_LLM_TYPE=\"azure_openai_chat\" # or openai_chat\nGRAPHRAG_LLM_DEPLOYMENT_NAME=\"gpt-4-turbo-preview\"\nGRAPHRAG_LLM_MODEL_SUPPORTS_JSON=True\n\n# Text Embedding Settings\nGRAPHRAG_EMBEDDING_TYPE=\"azure_openai_embedding\" # or openai_embedding\nGRAPHRAG_LLM_DEPLOYMENT_NAME=\"text-embedding-3-small\"\n\n# Data Mapping Settings\nGRAPHRAG_INPUT_TYPE=\"text\"\n</code></pre>"}, {"location": "config/template/#full-configuration", "title": "Full Configuration", "text": "<pre><code># Required LLM Config\n\n# Input Data Configuration\nGRAPHRAG_INPUT_TYPE=\"file\"\n\n# Plaintext Input Data Configuration\n# GRAPHRAG_INPUT_FILE_PATTERN=.*\\.txt\n\n# Text Input Data Configuration\nGRAPHRAG_INPUT_FILE_TYPE=\"text\"\nGRAPHRAG_INPUT_FILE_PATTERN=\".*\\.txt$\"\nGRAPHRAG_INPUT_SOURCE_COLUMN=source\n# GRAPHRAG_INPUT_TIMESTAMP_COLUMN=None\n# GRAPHRAG_INPUT_TIMESTAMP_FORMAT=None\n# GRAPHRAG_INPUT_TEXT_COLUMN=\"text\"\n# GRAPHRAG_INPUT_ATTRIBUTE_COLUMNS=id\n# GRAPHRAG_INPUT_TITLE_COLUMN=\"title\"\n# GRAPHRAG_INPUT_TYPE=\"file\"\n# GRAPHRAG_INPUT_CONNECTION_STRING=None\n# GRAPHRAG_INPUT_CONTAINER_NAME=None\n# GRAPHRAG_INPUT_BASE_DIR=None\n\n# Base LLM Settings\nGRAPHRAG_API_KEY=\"your_api_key\"\nGRAPHRAG_API_BASE=\"http://&lt;domain&gt;.openai.azure.com\" # For Azure OpenAI Users\nGRAPHRAG_API_VERSION=\"api_version\" # For Azure OpenAI Users\n# GRAPHRAG_API_ORGANIZATION=None\n# GRAPHRAG_API_PROXY=None\n\n# Text Generation Settings\n# GRAPHRAG_LLM_TYPE=openai_chat\nGRAPHRAG_LLM_API_KEY=\"your_api_key\" # If GRAPHRAG_API_KEY is not set\nGRAPHRAG_LLM_API_BASE=\"http://&lt;domain&gt;.openai.azure.com\" # For Azure OpenAI Users and if GRAPHRAG_API_BASE is not set\nGRAPHRAG_LLM_API_VERSION=\"api_version\" # For Azure OpenAI Users and if GRAPHRAG_API_VERSION is not set\nGRAPHRAG_LLM_MODEL_SUPPORTS_JSON=True # Suggested by default\n# GRAPHRAG_LLM_API_ORGANIZATION=None\n# GRAPHRAG_LLM_API_PROXY=None\n# GRAPHRAG_LLM_DEPLOYMENT_NAME=None\n# GRAPHRAG_LLM_MODEL=gpt-4-turbo-preview\n# GRAPHRAG_LLM_MAX_TOKENS=4000\n# GRAPHRAG_LLM_REQUEST_TIMEOUT=180\n# GRAPHRAG_LLM_THREAD_COUNT=50\n# GRAPHRAG_LLM_THREAD_STAGGER=0.3\n# GRAPHRAG_LLM_CONCURRENT_REQUESTS=25\n# GRAPHRAG_LLM_TPM=0\n# GRAPHRAG_LLM_RPM=0\n# GRAPHRAG_LLM_MAX_RETRIES=10\n# GRAPHRAG_LLM_MAX_RETRY_WAIT=10\n# GRAPHRAG_LLM_SLEEP_ON_RATE_LIMIT_RECOMMENDATION=True\n\n# Text Embedding Settings\n# GRAPHRAG_EMBEDDING_TYPE=openai_embedding\nGRAPHRAG_EMBEDDING_API_KEY=\"your_api_key\" # If GRAPHRAG_API_KEY is not set\nGRAPHRAG_EMBEDDING_API_BASE=\"http://&lt;domain&gt;.openai.azure.com\"  # For Azure OpenAI Users and if GRAPHRAG_API_BASE is not set\nGRAPHRAG_EMBEDDING_API_VERSION=\"api_version\" # For Azure OpenAI Users and if GRAPHRAG_API_VERSION is not set\n# GRAPHRAG_EMBEDDING_API_ORGANIZATION=None\n# GRAPHRAG_EMBEDDING_API_PROXY=None\n# GRAPHRAG_EMBEDDING_DEPLOYMENT_NAME=None\n# GRAPHRAG_EMBEDDING_MODEL=text-embedding-3-small\n# GRAPHRAG_EMBEDDING_BATCH_SIZE=16\n# GRAPHRAG_EMBEDDING_BATCH_MAX_TOKENS=8191\n# GRAPHRAG_EMBEDDING_TARGET=required\n# GRAPHRAG_EMBEDDING_SKIP=None\n# GRAPHRAG_EMBEDDING_THREAD_COUNT=None\n# GRAPHRAG_EMBEDDING_THREAD_STAGGER=50\n# GRAPHRAG_EMBEDDING_CONCURRENT_REQUESTS=25\n# GRAPHRAG_EMBEDDING_TPM=0\n# GRAPHRAG_EMBEDDING_RPM=0\n# GRAPHRAG_EMBEDDING_MAX_RETRIES=10\n# GRAPHRAG_EMBEDDING_MAX_RETRY_WAIT=10\n# GRAPHRAG_EMBEDDING_SLEEP_ON_RATE_LIMIT_RECOMMENDATION=True\n\n# Data Mapping Settings\n# GRAPHRAG_INPUT_ENCODING=utf-8\n\n# Data Chunking\n# GRAPHRAG_CHUNK_SIZE=1200\n# GRAPHRAG_CHUNK_OVERLAP=100\n# GRAPHRAG_CHUNK_BY_COLUMNS=id\n\n# Prompting Overrides\n# GRAPHRAG_ENTITY_EXTRACTION_PROMPT_FILE=None\n# GRAPHRAG_ENTITY_EXTRACTION_MAX_GLEANINGS=1\n# GRAPHRAG_ENTITY_EXTRACTION_ENTITY_TYPES=organization,person,event,geo\n# GRAPHRAG_SUMMARIZE_DESCRIPTIONS_PROMPT_FILE=None\n# GRAPHRAG_SUMMARIZE_DESCRIPTIONS_MAX_LENGTH=500\n# GRAPHRAG_CLAIM_EXTRACTION_DESCRIPTION=\"Any claims or facts that could be relevant to threat analysis.\"\n# GRAPHRAG_CLAIM_EXTRACTION_PROMPT_FILE=None\n# GRAPHRAG_CLAIM_EXTRACTION_MAX_GLEANINGS=1\n# GRAPHRAG_COMMUNITY_REPORT_PROMPT_FILE=None\n# GRAPHRAG_COMMUNITY_REPORT_MAX_LENGTH=1500\n\n# Storage\n# GRAPHRAG_STORAGE_TYPE=file\n# GRAPHRAG_STORAGE_CONNECTION_STRING=None\n# GRAPHRAG_STORAGE_CONTAINER_NAME=None\n# GRAPHRAG_STORAGE_BASE_DIR=None\n\n# Cache\n# GRAPHRAG_CACHE_TYPE=file\n# GRAPHRAG_CACHE_CONNECTION_STRING=None\n# GRAPHRAG_CACHE_CONTAINER_NAME=None\n# GRAPHRAG_CACHE_BASE_DIR=None\n\n# Reporting\n# GRAPHRAG_REPORTING_TYPE=file\n# GRAPHRAG_REPORTING_CONNECTION_STRING=None\n# GRAPHRAG_REPORTING_CONTAINER_NAME=None\n# GRAPHRAG_REPORTING_BASE_DIR=None\n\n# Node2Vec Parameters\n# GRAPHRAG_NODE2VEC_ENABLED=False\n# GRAPHRAG_NODE2VEC_NUM_WALKS=10\n# GRAPHRAG_NODE2VEC_WALK_LENGTH=40\n# GRAPHRAG_NODE2VEC_WINDOW_SIZE=2\n# GRAPHRAG_NODE2VEC_ITERATIONS=3\n# GRAPHRAG_NODE2VEC_RANDOM_SEED=597832\n\n# Data Snapshotting\n# GRAPHRAG_SNAPSHOT_GRAPHML=False\n# GRAPHRAG_SNAPSHOT_RAW_ENTITIES=False\n# GRAPHRAG_SNAPSHOT_TOP_LEVEL_NODES=False\n\n# Miscellaneous Settings\n# GRAPHRAG_ASYNC_MODE=asyncio\n# GRAPHRAG_ENCODING_MODEL=cl100k_base\n# GRAPHRAG_MAX_CLUSTER_SIZE=10\n# GRAPHRAG_SKIP_WORKFLOWS=None\n# GRAPHRAG_UMAP_ENABLED=False\n</code></pre>"}, {"location": "data/operation_dulce/ABOUT/", "title": "About", "text": "<p>This document (Operation Dulce) is an AI-generated science fiction novella, included here for the purposes of integration testing.</p>"}, {"location": "index/architecture/", "title": "Indexing Architecture", "text": ""}, {"location": "index/architecture/#key-concepts", "title": "Key Concepts", "text": ""}, {"location": "index/architecture/#knowledge-model", "title": "Knowledge Model", "text": "<p>In order to support the GraphRAG system, the outputs of the indexing engine (in the Default Configuration Mode) are aligned to a knowledge model we call the GraphRAG Knowledge Model. This model is designed to be an abstraction over the underlying data storage technology, and to provide a common interface for the GraphRAG system to interact with. In normal use-cases the outputs of the GraphRAG Indexer would be loaded into a database system, and the GraphRAG's Query Engine would interact with the database using the knowledge model data-store types.</p>"}, {"location": "index/architecture/#datashaper-workflows", "title": "DataShaper Workflows", "text": "<p>GraphRAG's Indexing Pipeline is built on top of our open-source library, DataShaper. DataShaper is a data processing library that allows users to declaratively express data pipelines, schemas, and related assets using well-defined schemas. DataShaper has implementations in JavaScript and Python, and is designed to be extensible to other languages.</p> <p>One of the core resource types within DataShaper is a Workflow. Workflows are expressed as sequences of steps, which we call verbs. Each step has a verb name and a configuration object. In DataShaper, these verbs model relational concepts such as SELECT, DROP, JOIN, etc.. Each verb transforms an input data table, and that table is passed down the pipeline.</p> <pre><code>---\ntitle: Sample Workflow\n---\nflowchart LR\n    input[Input Table] --&gt; select[SELECT] --&gt; join[JOIN] --&gt; binarize[BINARIZE] --&gt; output[Output Table]</code></pre>"}, {"location": "index/architecture/#llm-based-workflow-steps", "title": "LLM-based Workflow Steps", "text": "<p>GraphRAG's Indexing Pipeline implements a handful of custom verbs on top of the standard, relational verbs that our DataShaper library provides. These verbs give us the ability to augment text documents with rich, structured data using the power of LLMs such as GPT-4. We utilize these verbs in our standard workflow to extract entities, relationships, claims, community structures, and community reports and summaries. This behavior is customizable and can be extended to support many kinds of AI-based data enrichment and extraction tasks.</p>"}, {"location": "index/architecture/#workflow-graphs", "title": "Workflow Graphs", "text": "<p>Because of the complexity of our data indexing tasks, we needed to be able to express our data pipeline as series of multiple, interdependent workflows. In the GraphRAG Indexing Pipeline, each workflow may define dependencies on other workflows, effectively forming a directed acyclic graph (DAG) of workflows, which is then used to schedule processing.</p> <pre><code>---\ntitle: Sample Workflow DAG\n---\nstateDiagram-v2\n    [*] --&gt; Prepare\n    Prepare --&gt; Chunk\n    Chunk --&gt; ExtractGraph\n    Chunk --&gt; EmbedDocuments\n    ExtractGraph --&gt; GenerateReports\n    ExtractGraph --&gt; EmbedEntities\n    ExtractGraph --&gt; EmbedGraph</code></pre>"}, {"location": "index/architecture/#dataframe-message-format", "title": "Dataframe Message Format", "text": "<p>The primary unit of communication between workflows, and between workflow steps is an instance of <code>pandas.DataFrame</code>. Although side-effects are possible, our goal is to be data-centric and table-centric in our approach to data processing. This allows us to easily reason about our data, and to leverage the power of dataframe-based ecosystems. Our underlying dataframe technology may change over time, but our primary goal is to support the DataShaper workflow schema while retaining single-machine ease of use and developer ergonomics.</p>"}, {"location": "index/architecture/#llm-caching", "title": "LLM Caching", "text": "<p>The GraphRAG library was designed with LLM interactions in mind, and a common setback when working with LLM APIs is various errors due to network latency, throttling, etc.. Because of these potential error cases, we've added a cache layer around LLM interactions. When completion requests are made using the same input set (prompt and tuning parameters), we return a cached result if one exists. This allows our indexer to be more resilient to network issues, to act idempotently, and to provide a more efficient end-user experience.</p>"}, {"location": "index/default_dataflow/", "title": "Indexing Dataflow", "text": ""}, {"location": "index/default_dataflow/#the-graphrag-knowledge-model", "title": "The GraphRAG Knowledge Model", "text": "<p>The knowledge model is a specification for data outputs that conform to our data-model definition. You can find these definitions in the python/graphrag/graphrag/model folder within the GraphRAG repository. The following entity types are provided. The fields here represent the fields that are text-embedded by default.</p> <ul> <li><code>Document</code> - An input document into the system. These either represent individual rows in a CSV or individual .txt file.</li> <li><code>TextUnit</code> - A chunk of text to analyze. The size of these chunks, their overlap, and whether they adhere to any data boundaries may be configured below. A common use case is to set <code>CHUNK_BY_COLUMNS</code> to <code>id</code> so that there is a 1-to-many relationship between documents and TextUnits instead of a many-to-many.</li> <li><code>Entity</code> - An entity extracted from a TextUnit. These represent people, places, events, or some other entity-model that you provide.</li> <li><code>Relationship</code> - A relationship between two entities. These are generated from the covariates.</li> <li><code>Covariate</code> - Extracted claim information, which contains statements about entities which may be time-bound.</li> <li><code>Community Report</code> - Once entities are generated, we perform hierarchical community detection on them and generate reports for each community in this hierarchy.</li> <li><code>Node</code> - This table contains layout information for rendered graph-views of the Entities and Documents which have been embedded and clustered.</li> </ul>"}, {"location": "index/default_dataflow/#the-default-configuration-workflow", "title": "The Default Configuration Workflow", "text": "<p>Let's take a look at how the default-configuration workflow transforms text documents into the GraphRAG Knowledge Model. This page gives a general overview of the major steps in this process. To fully configure this workflow, check out the configuration documentation.</p> <pre><code>---\ntitle: Dataflow Overview\n---\nflowchart TB\n    subgraph phase1[Phase 1: Compose TextUnits]\n    documents[Documents] --&gt; chunk[Chunk]\n    chunk --&gt; embed[Embed] --&gt; textUnits[Text Units]\n    end\n    subgraph phase2[Phase 2: Graph Extraction]\n    textUnits --&gt; graph_extract[Entity &amp; Relationship Extraction]\n    graph_extract --&gt; graph_summarize[Entity &amp; Relationship Summarization]\n    graph_summarize --&gt; claim_extraction[Claim Extraction]\n    claim_extraction --&gt; graph_outputs[Graph Tables]\n    end\n    subgraph phase3[Phase 3: Graph Augmentation]\n    graph_outputs --&gt; community_detect[Community Detection]\n    community_detect --&gt; graph_embed[Graph Embedding]\n    graph_embed --&gt; augmented_graph[Augmented Graph Tables]\n    end\n    subgraph phase4[Phase 4: Community Summarization]\n    augmented_graph --&gt; summarized_communities[Community Summarization]\n    summarized_communities --&gt; embed_communities[Community Embedding]\n    embed_communities --&gt; community_outputs[Community Tables]\n    end\n    subgraph phase5[Phase 5: Document Processing]\n    documents --&gt; link_to_text_units[Link to TextUnits]\n    textUnits --&gt; link_to_text_units\n    link_to_text_units --&gt; embed_documents[Document Embedding]\n    embed_documents --&gt; document_graph[Document Graph Creation]\n    document_graph --&gt; document_outputs[Document Tables]\n    end\n    subgraph phase6[Phase 6: Network Visualization]\n    document_outputs --&gt; umap_docs[Umap Documents]\n    augmented_graph --&gt; umap_entities[Umap Entities]\n    umap_docs --&gt; combine_nodes[Nodes Table]\n    umap_entities --&gt; combine_nodes\n    end</code></pre>"}, {"location": "index/default_dataflow/#phase-1-compose-textunits", "title": "Phase 1: Compose TextUnits", "text": "<p>The first phase of the default-configuration workflow is to transform input documents into TextUnits. A TextUnit is a chunk of text that is used for our graph extraction techniques. They are also used as source-references by extracted knowledge items in order to empower breadcrumbs and provenance by concepts back to their original source tex.</p> <p>The chunk size (counted in tokens), is user-configurable. By default this is set to 300 tokens, although we've had positive experience with 1200-token chunks using a single \"glean\" step. (A \"glean\" step is a follow-on extraction). Larger chunks result in lower-fidelity output and less meaningful reference texts; however, using larger chunks can result in much faster processing time.</p> <p>The group-by configuration is also user-configurable. By default, we align our chunks to document boundaries, meaning that there is a strict 1-to-many relationship between Documents and TextUnits. In rare cases, this can be turned into a many-to-many relationship. This is useful when the documents are very short and we need several of them to compose a meaningful analysis unit (e.g. Tweets or a chat log)</p> <p>Each of these text-units are text-embedded and passed into the next phase of the pipeline.</p> <pre><code>---\ntitle: Documents into Text Chunks\n---\nflowchart LR\n    doc1[Document 1] --&gt; tu1[TextUnit 1]\n    doc1 --&gt; tu2[TextUnit 2]\n    doc2[Document 2] --&gt; tu3[TextUnit 3]\n    doc2 --&gt; tu4[TextUnit 4]\n</code></pre>"}, {"location": "index/default_dataflow/#phase-2-graph-extraction", "title": "Phase 2: Graph Extraction", "text": "<p>In this phase, we analyze each text unit and extract our graph primitives: Entities, Relationships, and Claims. Entities and Relationships are extracted at once in our entity_extract verb, and claims are extracted in our claim_extract verb. Results are then combined and passed into following phases of the pipeline.</p> <pre><code>---\ntitle: Graph Extraction\n---\nflowchart LR\n    tu[TextUnit] --&gt; ge[Graph Extraction] --&gt; gs[Graph Summarization]\n    tu --&gt; ce[Claim Extraction]</code></pre>"}, {"location": "index/default_dataflow/#entity-relationship-extraction", "title": "Entity &amp; Relationship Extraction", "text": "<p>In this first step of graph extraction, we process each text-unit in order to extract entities and relationships out of the raw text using the LLM. The output of this step is a subgraph-per-TextUnit containing a list of entities with a name, type, and description, and a list of relationships with a source, target, and description.</p> <p>These subgraphs are merged together - any entities with the same name and type are merged by creating an array of their descriptions. Similarly, any relationships with the same source and target are merged by creating an array of their descriptions.</p>"}, {"location": "index/default_dataflow/#entity-relationship-summarization", "title": "Entity &amp; Relationship Summarization", "text": "<p>Now that we have a graph of entities and relationships, each with a list of descriptions, we can summarize these lists into a single description per entity and relationship. This is done by asking the LLM for a short summary that captures all of the distinct information from each description. This allows all of our entities and relationships to have a single concise description.</p>"}, {"location": "index/default_dataflow/#claim-extraction-emission", "title": "Claim Extraction &amp; Emission", "text": "<p>Finally, as an independent workflow, we extract claims from the source TextUnits. These claims represent positive factual statements with an evaluated status and time-bounds. These are emitted as a primary artifact called Covariates.</p> <p>Note: claim extraction is optional and turned off by default. This is because claim extraction generally needs prompt tuning to be useful.</p>"}, {"location": "index/default_dataflow/#phase-3-graph-augmentation", "title": "Phase 3: Graph Augmentation", "text": "<p>Now that we have a usable graph of entities and relationships, we want to understand their community structure and augment the graph with additional information. This is done in two steps: Community Detection and Graph Embedding. These give us explicit (communities) and implicit (embeddings) ways of understanding the topological structure of our graph.</p> <pre><code>---\ntitle: Graph Augmentation\n---\nflowchart LR\n    cd[Leiden Hierarchical Community Detection] --&gt; ge[Node2Vec Graph Embedding] --&gt; ag[Graph Table Emission]</code></pre>"}, {"location": "index/default_dataflow/#community-detection", "title": "Community Detection", "text": "<p>In this step, we generate a hierarchy of entity communities using the Hierarchical Leiden Algorithm. This method will apply a recursive community-clustering to our graph until we reach a community-size threshold. This will allow us to understand the community structure of our graph and provide a way to navigate and summarize the graph at different levels of granularity.</p>"}, {"location": "index/default_dataflow/#graph-embedding", "title": "Graph Embedding", "text": "<p>In this step, we generate a vector representation of our graph using the Node2Vec algorithm. This will allow us to understand the implicit structure of our graph and provide an additional vector-space in which to search for related concepts during our query phase.</p>"}, {"location": "index/default_dataflow/#graph-tables-emission", "title": "Graph Tables Emission", "text": "<p>Once our graph augmentation steps are complete, the final Entities and Relationships tables are emitted after their text fields are text-embedded.</p>"}, {"location": "index/default_dataflow/#phase-4-community-summarization", "title": "Phase 4: Community Summarization", "text": "<pre><code>---\ntitle: Community Summarization\n---\nflowchart LR\n    sc[Generate Community Reports] --&gt; ss[Summarize Community Reports] --&gt; ce[Community Embedding] --&gt; co[Community Tables Emission]</code></pre> <p>At this point, we have a functional graph of entities and relationships, a hierarchy of communities for the entities, as well as node2vec embeddings.</p> <p>Now we want to build on the communities data and generate reports for each community. This gives us a high-level understanding of the graph at several points of graph granularity. For example, if community A is the top-level community, we'll get a report about the entire graph. If the community is lower-level, we'll get a report about a local cluster.</p>"}, {"location": "index/default_dataflow/#generate-community-reports", "title": "Generate Community Reports", "text": "<p>In this step, we generate a summary of each community using the LLM. This will allow us to understand the distinct information contained within each community and provide a scoped understanding of the graph, from either a high-level or a low-level perspective. These reports contain an executive overview and reference the key entities, relationships, and claims within the community sub-structure.</p>"}, {"location": "index/default_dataflow/#summarize-community-reports", "title": "Summarize Community Reports", "text": "<p>In this step, each community report is then summarized via the LLM for shorthand use.</p>"}, {"location": "index/default_dataflow/#community-embedding", "title": "Community Embedding", "text": "<p>In this step, we generate a vector representation of our communities by generating text embeddings of the community report, the community report summary, and the title of the community report.</p>"}, {"location": "index/default_dataflow/#community-tables-emission", "title": "Community Tables Emission", "text": "<p>At this point, some bookkeeping work is performed and we emit the Communities and CommunityReports tables.</p>"}, {"location": "index/default_dataflow/#phase-5-document-processing", "title": "Phase 5: Document Processing", "text": "<p>In this phase of the workflow, we create the Documents table for the knowledge model.</p> <pre><code>---\ntitle: Document Processing\n---\nflowchart LR\n    aug[Augment] --&gt; dp[Link to TextUnits] --&gt; de[Avg. Embedding] --&gt; dg[Document Table Emission]</code></pre>"}, {"location": "index/default_dataflow/#augment-with-columns-csv-only", "title": "Augment with Columns (CSV Only)", "text": "<p>If the workflow is operating on CSV data, you may configure your workflow to add additional fields to Documents output. These fields should exist on the incoming CSV tables. Details about configuring this can be found in the configuration documentation.</p>"}, {"location": "index/default_dataflow/#link-to-textunits", "title": "Link to TextUnits", "text": "<p>In this step, we link each document to the text-units that were created in the first phase. This allows us to understand which documents are related to which text-units and vice-versa.</p>"}, {"location": "index/default_dataflow/#document-embedding", "title": "Document Embedding", "text": "<p>In this step, we generate a vector representation of our documents using an average embedding of document slices. We re-chunk documents without overlapping chunks, and then generate an embedding for each chunk. We create an average of these chunks weighted by token-count and use this as the document embedding. This will allow us to understand the implicit relationship between documents, and will help us generate a network representation of our documents.</p>"}, {"location": "index/default_dataflow/#documents-table-emission", "title": "Documents Table Emission", "text": "<p>At this point, we can emit the Documents table into the knowledge Model.</p>"}, {"location": "index/default_dataflow/#phase-6-network-visualization", "title": "Phase 6: Network Visualization", "text": "<p>In this phase of the workflow, we perform some steps to support network visualization of our high-dimensional vector spaces within our existing graphs. At this point there are two logical graphs at play: the Entity-Relationship graph and the Document graph.</p> <pre><code>---\ntitle: Network Visualization Workflows\n---\nflowchart LR\n    nv[Umap Documents] --&gt; ne[Umap Entities] --&gt; ng[Nodes Table Emission]</code></pre> <p>For each of the logical graphs, we perform a UMAP dimensionality reduction to generate a 2D representation of the graph. This will allow us to visualize the graph in a 2D space and understand the relationships between the nodes in the graph. The UMAP embeddings are then emitted as a table of Nodes. The rows of this table include a discriminator indicating whether the node is a document or an entity, and the UMAP coordinates.</p>"}, {"location": "index/overview/", "title": "GraphRAG Indexing \ud83e\udd16", "text": "<p>The GraphRAG indexing package is a data pipeline and transformation suite that is designed to extract meaningful, structured data from unstructured text using LLMs.</p> <p>Indexing Pipelines are configurable. They are composed of workflows, standard and custom steps, prompt templates, and input/output adapters. Our standard pipeline is designed to:</p> <ul> <li>extract entities, relationships and claims from raw text</li> <li>perform community detection in entities</li> <li>generate community summaries and reports at multiple levels of granularity</li> <li>embed entities into a graph vector space</li> <li>embed text chunks into a textual vector space</li> </ul> <p>The outputs of the pipeline can be stored in a variety of formats, including JSON and Parquet - or they can be handled manually via the Python API.</p>"}, {"location": "index/overview/#getting-started", "title": "Getting Started", "text": ""}, {"location": "index/overview/#requirements", "title": "Requirements", "text": "<p>See the requirements section in Get Started for details on setting up a development environment.</p> <p>The Indexing Engine can be used in either a default configuration mode or with a custom pipeline. To configure GraphRAG, see the configuration documentation. After you have a config file you can run the pipeline using the CLI or the Python API.</p>"}, {"location": "index/overview/#usage", "title": "Usage", "text": ""}, {"location": "index/overview/#cli", "title": "CLI", "text": "<pre><code># Via Poetry\npoetry run poe cli --root &lt;data_root&gt; # default config mode\npoetry run poe cli --config your_pipeline.yml # custom config mode\n\n# Via Node\nyarn run:index --root &lt;data_root&gt; # default config mode\nyarn run:index --config your_pipeline.yml # custom config mode\n</code></pre>"}, {"location": "index/overview/#python-api", "title": "Python API", "text": "<pre><code>from graphrag.index import run_pipeline\nfrom graphrag.index.config import PipelineWorkflowReference\n\nworkflows: list[PipelineWorkflowReference] = [\n    PipelineWorkflowReference(\n        steps=[\n            {\n                # built-in verb\n                \"verb\": \"derive\",  # https://github.com/microsoft/datashaper/blob/main/python/datashaper/datashaper/verbs/derive.py\n                \"args\": {\n                    \"column1\": \"col1\",  # from above\n                    \"column2\": \"col2\",  # from above\n                    \"to\": \"col_multiplied\",  # new column name\n                    \"operator\": \"*\",  # multiply the two columns\n                },\n                # Since we're trying to act on the default input, we don't need explicitly to specify an input\n            }\n        ]\n    ),\n]\n\ndataset = pd.DataFrame([{\"col1\": 2, \"col2\": 4}, {\"col1\": 5, \"col2\": 10}])\noutputs = []\nasync for output in await run_pipeline(dataset=dataset, workflows=workflows):\n    outputs.append(output)\npipeline_result = outputs[-1]\nprint(pipeline_result)\n</code></pre>"}, {"location": "index/overview/#further-reading", "title": "Further Reading", "text": "<ul> <li>To start developing within the GraphRAG project, see getting started</li> <li>To understand the underlying concepts and execution model of the indexing library, see the architecture documentation</li> <li>To get running with a series of examples, see the examples documentation</li> <li>To read more about configuring the indexing engine, see the configuration documentation</li> </ul>"}, {"location": "prompt_tuning/auto_prompt_tuning/", "title": "Auto Prompt Tuning \u2699\ufe0f", "text": "<p>GraphRAG provides the ability to create domain adapted prompts for the generation of the knowledge graph. This step is optional, though it is highly encouraged to run it as it will yield better results when executing an Index Run.</p> <p>These are generated by loading the inputs, splitting them into chunks (text units) and then running a series of LLM invocations and template substitutions to generate the final prompts. We suggest using the default values provided by the script, but in this page you'll find the detail of each in case you want to further explore and tweak the prompt tuning algorithm.</p> <p> </p> <p> Figure 1: Auto Tuning Conceptual Diagram. </p>"}, {"location": "prompt_tuning/auto_prompt_tuning/#prerequisites", "title": "Prerequisites", "text": "<p>Before running auto tuning, ensure you have already initialized your workspace with the <code>graphrag init</code> command. This will create the necessary configuration files and the default prompts. Refer to the Init Documentation for more information about the initialization process.</p>"}, {"location": "prompt_tuning/auto_prompt_tuning/#usage", "title": "Usage", "text": "<p>You can run the main script from the command line with various options:</p> <pre><code>graphrag prompt-tune [--root ROOT] [--domain DOMAIN]  [--method METHOD] [--limit LIMIT] [--language LANGUAGE] \\\n[--max-tokens MAX_TOKENS] [--chunk-size CHUNK_SIZE] [--n-subset-max N_SUBSET_MAX] [--k K] \\\n[--min-examples-required MIN_EXAMPLES_REQUIRED] [--no-entity-types] [--output OUTPUT]\n</code></pre>"}, {"location": "prompt_tuning/auto_prompt_tuning/#command-line-options", "title": "Command-Line Options", "text": "<ul> <li> <p><code>--config</code> (required): The path to the configuration file. This is required to load the data and model settings.</p> </li> <li> <p><code>--root</code> (optional): The data project root directory, including the config files (YML, JSON, or .env). Defaults to the current directory.</p> </li> <li> <p><code>--domain</code> (optional): The domain related to your input data, such as 'space science', 'microbiology', or 'environmental news'. If left empty, the domain will be inferred from the input data.</p> </li> <li> <p><code>--method</code> (optional): The method to select documents. Options are all, random, auto or top. Default is random.</p> </li> <li> <p><code>--limit</code> (optional): The limit of text units to load when using random or top selection. Default is 15.</p> </li> <li> <p><code>--language</code> (optional): The language to use for input processing. If it is different from the inputs' language, the LLM will translate. Default is \"\" meaning it will be automatically detected from the inputs.</p> </li> <li> <p><code>--max-tokens</code> (optional): Maximum token count for prompt generation. Default is 2000.</p> </li> <li> <p><code>--chunk-size</code> (optional): The size in tokens to use for generating text units from input documents. Default is 200.</p> </li> <li> <p><code>--n-subset-max</code> (optional): The number of text chunks to embed when using auto selection method. Default is 300.</p> </li> <li> <p><code>--k</code> (optional): The number of documents to select when using auto selection method. Default is 15.</p> </li> <li> <p><code>--min-examples-required</code> (optional): The minimum number of examples required for entity extraction prompts. Default is 2.</p> </li> <li> <p><code>--no-entity-types</code> (optional): Use untyped entity extraction generation. We recommend using this when your data covers a lot of topics or it is highly randomized.</p> </li> <li> <p><code>--output</code> (optional): The folder to save the generated prompts. Default is \"prompts\".</p> </li> </ul>"}, {"location": "prompt_tuning/auto_prompt_tuning/#example-usage", "title": "Example Usage", "text": "<pre><code>python -m graphrag prompt-tune --root /path/to/project --config /path/to/settings.yaml --domain \"environmental news\" \\\n--method random --limit 10 --language English --max-tokens 2048 --chunk-size 256 --min-examples-required 3 \\\n--no-entity-types --output /path/to/output\n</code></pre> <p>or, with minimal configuration (suggested):</p> <pre><code>python -m graphrag prompt-tune --root /path/to/project --config /path/to/settings.yaml --no-entity-types\n</code></pre>"}, {"location": "prompt_tuning/auto_prompt_tuning/#document-selection-methods", "title": "Document Selection Methods", "text": "<p>The auto tuning feature ingests the input data and then divides it into text units the size of the chunk size parameter. After that, it uses one of the following selection methods to pick a sample to work with for prompt generation:</p> <ul> <li><code>random</code>: Select text units randomly. This is the default and recommended option.</li> <li><code>top</code>: Select the head n text units.</li> <li><code>all</code>: Use all text units for the generation. Use only with small datasets; this option is not usually recommended.</li> <li><code>auto</code>: Embed text units in a lower-dimensional space and select the k nearest neighbors to the centroid. This is useful when you have a large dataset and want to select a representative sample.</li> </ul>"}, {"location": "prompt_tuning/auto_prompt_tuning/#modify-env-vars", "title": "Modify Env Vars", "text": "<p>After running auto tuning, you should modify the following environment variables (or config variables) to pick up the new prompts on your index run. Note: Please make sure to update the correct path to the generated prompts, in this example we are using the default \"prompts\" path.</p> <ul> <li> <p><code>GRAPHRAG_ENTITY_EXTRACTION_PROMPT_FILE</code> = \"prompts/entity_extraction.txt\"</p> </li> <li> <p><code>GRAPHRAG_COMMUNITY_REPORT_PROMPT_FILE</code> = \"prompts/community_report.txt\"</p> </li> <li> <p><code>GRAPHRAG_SUMMARIZE_DESCRIPTIONS_PROMPT_FILE</code> = \"prompts/summarize_descriptions.txt\"</p> </li> </ul> <p>or in your yaml config file:</p> <pre><code>entity_extraction:\n  prompt: \"prompts/entity_extraction.txt\"\n\nsummarize_descriptions:\n  prompt: \"prompts/summarize_descriptions.txt\"\n\ncommunity_reports:\n  prompt: \"prompts/community_report.txt\"\n</code></pre>"}, {"location": "prompt_tuning/manual_prompt_tuning/", "title": "Manual Prompt Tuning \u2699\ufe0f", "text": "<p>The GraphRAG indexer, by default, will run with a handful of prompts that are designed to work well in the broad context of knowledge discovery. However, it is quite common to want to tune the prompts to better suit your specific use case. We provide a means for you to do this by allowing you to specify a custom prompt file, which will each use a series of token-replacements internally.</p> <p>Each of these prompts may be overridden by writing a custom prompt file in plaintext. We use token-replacements in the form of <code>{token_name}</code>, and the descriptions for the available tokens can be found below.</p>"}, {"location": "prompt_tuning/manual_prompt_tuning/#entityrelationship-extraction", "title": "Entity/Relationship Extraction", "text": "<p>Prompt Source</p>"}, {"location": "prompt_tuning/manual_prompt_tuning/#tokens-values-provided-by-extractor", "title": "Tokens (values provided by extractor)", "text": "<ul> <li>{input_text} - The input text to be processed.</li> <li>{entity_types} - A list of entity types</li> <li>{tuple_delimiter} - A delimiter for separating values within a tuple. A single tuple is used to represent an individual entity or relationship.</li> <li>{record_delimiter} - A delimiter for separating tuple instances.</li> <li>{completion_delimiter} - An indicator for when generation is complete.</li> </ul>"}, {"location": "prompt_tuning/manual_prompt_tuning/#summarize-entityrelationship-descriptions", "title": "Summarize Entity/Relationship Descriptions", "text": "<p>Prompt Source</p>"}, {"location": "prompt_tuning/manual_prompt_tuning/#tokens-values-provided-by-extractor_1", "title": "Tokens (values provided by extractor)", "text": "<ul> <li>{entity_name} - The name of the entity or the source/target pair of the relationship.</li> <li>{description_list} - A list of descriptions for the entity or relationship.</li> </ul>"}, {"location": "prompt_tuning/manual_prompt_tuning/#claim-extraction", "title": "Claim Extraction", "text": "<p>Prompt Source</p>"}, {"location": "prompt_tuning/manual_prompt_tuning/#tokens-values-provided-by-extractor_2", "title": "Tokens (values provided by extractor)", "text": "<ul> <li>{input_text} - The input text to be processed.</li> <li>{tuple_delimiter} - A delimiter for separating values within a tuple. A single tuple is used to represent an individual entity or relationship.</li> <li>{record_delimiter} - A delimiter for separating tuple instances.</li> <li>{completion_delimiter} - An indicator for when generation is complete.</li> </ul> <p>Note: there is additional parameter for the <code>Claim Description</code> that is used in claim extraction. The default value is</p> <p><code>\"Any claims or facts that could be relevant to information discovery.\"</code></p> <p>See the configuration documentation for details on how to change this.</p>"}, {"location": "prompt_tuning/manual_prompt_tuning/#generate-community-reports", "title": "Generate Community Reports", "text": "<p>Prompt Source</p>"}, {"location": "prompt_tuning/manual_prompt_tuning/#tokens-values-provided-by-extractor_3", "title": "Tokens (values provided by extractor)", "text": "<ul> <li>{input_text} - The input text to generate the report with. This will contain tables of entities and relationships.</li> </ul>"}, {"location": "prompt_tuning/overview/", "title": "Prompt Tuning \u2699\ufe0f", "text": "<p>This page provides an overview of the prompt tuning options available for the GraphRAG indexing engine.</p>"}, {"location": "prompt_tuning/overview/#default-prompts", "title": "Default Prompts", "text": "<p>The default prompts are the simplest way to get started with the GraphRAG system. It is designed to work out-of-the-box with minimal configuration. You can find more detail about these prompts in the following links:</p> <ul> <li>Entity/Relationship Extraction</li> <li>Entity/Relationship Description Summarization</li> <li>Claim Extraction</li> <li>Community Reports</li> </ul>"}, {"location": "prompt_tuning/overview/#auto-tuning", "title": "Auto Tuning", "text": "<p>Auto Tuning leverages your input data and LLM interactions to create domain adapted prompts for the generation of the knowledge graph. It is highly encouraged to run it as it will yield better results when executing an Index Run. For more details about how to use it, please refer to the Auto Tuning documentation.</p>"}, {"location": "prompt_tuning/overview/#manual-tuning", "title": "Manual Tuning", "text": "<p>Manual tuning is an advanced use-case. Most users will want to use the Auto Tuning feature instead. Details about how to use manual configuration are available in the Manual Tuning documentation.</p>"}, {"location": "query/global_search/", "title": "Global Search \ud83d\udd0e", "text": ""}, {"location": "query/global_search/#whole-dataset-reasoning", "title": "Whole Dataset Reasoning", "text": "<p>Baseline RAG struggles with queries that require aggregation of information across the dataset to compose an answer. Queries such as \u201cWhat are the top 5 themes in the data?\u201d perform terribly because baseline RAG relies on a vector search of semantically similar text content within the dataset. There is nothing in the query to direct it to the correct information.</p> <p>However, with GraphRAG we can answer such questions, because the structure of the LLM-generated knowledge graph tells us about the structure (and thus themes) of the dataset as a whole. This allows the private dataset to be organized into meaningful semantic clusters that are pre-summarized. Using our global search method, the LLM uses these clusters to summarize these themes when responding to a user query.</p>"}, {"location": "query/global_search/#methodology", "title": "Methodology", "text": "<pre><code>---\ntitle: Global Search Dataflow\n---\n%%{ init: { 'flowchart': { 'curve': 'step' } } }%%\nflowchart LR\n\n    uq[User Query] --- .1\n    ch1[Conversation History] --- .1\n\n    subgraph RIR\n        direction TB\n        ri1[Rated Intermediate&lt;br/&gt;Response 1]~~~ri2[Rated Intermediate&lt;br/&gt;Response 2] -.\"{1..N}\".-rin[Rated Intermediate&lt;br/&gt;Response N]\n    end\n\n    .1--Shuffled Community&lt;br/&gt;Report Batch 1--&gt;RIR\n    .1--Shuffled Community&lt;br/&gt;Report Batch 2--&gt;RIR---.2\n    .1--Shuffled Community&lt;br/&gt;Report Batch N--&gt;RIR\n\n    .2--Ranking +&lt;br/&gt;Filtering--&gt;agr[Aggregated Intermediate&lt;br/&gt;Responses]--&gt;res[Response]\n\n\n\n     classDef green fill:#26B653,stroke:#333,stroke-width:2px,color:#fff;\n     classDef turquoise fill:#19CCD3,stroke:#333,stroke-width:2px,color:#fff;\n     classDef rose fill:#DD8694,stroke:#333,stroke-width:2px,color:#fff;\n     classDef orange fill:#F19914,stroke:#333,stroke-width:2px,color:#fff;\n     classDef purple fill:#B356CD,stroke:#333,stroke-width:2px,color:#fff;\n     classDef invisible fill:#fff,stroke:#fff,stroke-width:0px,color:#fff, width:0px;\n     class uq,ch1 turquoise;\n     class ri1,ri2,rin rose;\n     class agr orange;\n     class res purple;\n     class .1,.2 invisible;\n</code></pre> <p>Given a user query and, optionally, the conversation history, the global search method uses a collection of LLM-generated community reports from a specified level of the graph's community hierarchy as context data to generate response in a map-reduce manner. At the <code>map</code> step, community reports are segmented into text chunks of pre-defined size. Each text chunk is then used to produce an intermediate response containing a list of point, each of which is accompanied by a numerical rating indicating the importance of the point. At the <code>reduce</code> step, a filtered set of the most important points from the intermediate responses are aggregated and used as the context to generate the final response. </p> <p>The quality of the global search\u2019s response can be heavily influenced by the level of the community hierarchy chosen for sourcing community reports. Lower hierarchy levels, with their detailed reports, tend to yield more thorough responses, but may also increase the time and LLM resources needed to generate the final response due to the volume of reports.</p>"}, {"location": "query/global_search/#configuration", "title": "Configuration", "text": "<p>Below are the key parameters of the GlobalSearch class:</p> <ul> <li><code>llm</code>: OpenAI model object to be used for response generation</li> <li><code>context_builder</code>: context builder object to be used for preparing context data from community reports</li> <li><code>map_system_prompt</code>: prompt template used in the <code>map</code> stage. Default template can be found at map_system_prompt</li> <li><code>reduce_system_prompt</code>: prompt template used in the <code>reduce</code> stage, default template can be found at reduce_system_prompt</li> <li><code>response_type</code>: free-form text describing the desired response type and format (e.g., <code>Multiple Paragraphs</code>, <code>Multi-Page Report</code>)</li> <li><code>allow_general_knowledge</code>: setting this to True will include additional instructions to the <code>reduce_system_prompt</code> to prompt the LLM to incorporate relevant real-world knowledge outside of the dataset. Note that this may increase hallucinations, but can be useful for certain scenarios. Default is False *<code>general_knowledge_inclusion_prompt</code>: instruction to add to the <code>reduce_system_prompt</code> if <code>allow_general_knowledge</code> is enabled. Default instruction can be found at general_knowledge_instruction</li> <li><code>max_data_tokens</code>: token budget for the context data</li> <li><code>map_llm_params</code>: a dictionary of additional parameters (e.g., temperature, max_tokens) to be passed to the LLM call at the <code>map</code> stage</li> <li><code>reduce_llm_params</code>: a dictionary of additional parameters (e.g., temperature, max_tokens) to passed to the LLM call at the <code>reduce</code> stage</li> <li><code>context_builder_params</code>: a dictionary of additional parameters to be passed to the <code>context_builder</code> object when building context window for the <code>map</code> stage.</li> <li><code>concurrent_coroutines</code>: controls the degree of parallelism in the <code>map</code> stage.</li> <li><code>callbacks</code>: optional callback functions, can be used to provide custom event handlers for LLM's completion streaming events</li> </ul>"}, {"location": "query/global_search/#how-to-use", "title": "How to Use", "text": "<p>An example of a global search scenario can be found in the following notebook.</p>"}, {"location": "query/local_search/", "title": "Local Search \ud83d\udd0e", "text": ""}, {"location": "query/local_search/#entity-based-reasoning", "title": "Entity-based Reasoning", "text": "<p>The local search method combines structured data from the knowledge graph with unstructured data from the input documents to augment the LLM context with relevant entity information at query time. It is well-suited for answering questions that require an understanding of specific entities mentioned in the input documents (e.g., \u201cWhat are the healing properties of chamomile?\u201d).</p>"}, {"location": "query/local_search/#methodology", "title": "Methodology", "text": "<pre><code>---\ntitle: Local Search Dataflow\n---\n%%{ init: { 'flowchart': { 'curve': 'step' } } }%%\nflowchart LR\n\n    uq[User Query] ---.1\n    ch1[Conversation&lt;br/&gt;History]---.1\n\n    .1--Entity&lt;br/&gt;Description&lt;br/&gt;Embedding--&gt; ee[Extracted Entities]\n\n    ee[Extracted Entities] ---.2--Entity-Text&lt;br/&gt;Unit Mapping--&gt; ctu[Candidate&lt;br/&gt;Text Units]--Ranking + &lt;br/&gt;Filtering --&gt;ptu[Prioritized&lt;br/&gt;Text Units]---.3\n    .2--Entity-Report&lt;br/&gt;Mapping--&gt; ccr[Candidate&lt;br/&gt;Community Reports]--Ranking + &lt;br/&gt;Filtering --&gt;pcr[Prioritized&lt;br/&gt;Community Reports]---.3\n    .2--Entity-Entity&lt;br/&gt;Relationships--&gt; ce[Candidate&lt;br/&gt;Entities]--Ranking + &lt;br/&gt;Filtering --&gt;pe[Prioritized&lt;br/&gt;Entities]---.3\n    .2--Entity-Entity&lt;br/&gt;Relationships--&gt; cr[Candidate&lt;br/&gt;Relationships]--Ranking + &lt;br/&gt;Filtering --&gt;pr[Prioritized&lt;br/&gt;Relationships]---.3\n    .2--Entity-Covariate&lt;br/&gt;Mappings--&gt; cc[Candidate&lt;br/&gt;Covariates]--Ranking + &lt;br/&gt;Filtering --&gt;pc[Prioritized&lt;br/&gt;Covariates]---.3\n    ch1 --&gt;ch2[Conversation History]---.3\n    .3--&gt;res[Response]\n\n     classDef green fill:#26B653,stroke:#333,stroke-width:2px,color:#fff;\n     classDef turquoise fill:#19CCD3,stroke:#333,stroke-width:2px,color:#fff;\n     classDef rose fill:#DD8694,stroke:#333,stroke-width:2px,color:#fff;\n     classDef orange fill:#F19914,stroke:#333,stroke-width:2px,color:#fff;\n     classDef purple fill:#B356CD,stroke:#333,stroke-width:2px,color:#fff;\n     classDef invisible fill:#fff,stroke:#fff,stroke-width:0px,color:#fff, width:0px;\n     class uq,ch1 turquoise\n     class ee green\n     class ctu,ccr,ce,cr,cc rose\n     class ptu,pcr,pe,pr,pc,ch2 orange\n     class res purple\n     class .1,.2,.3 invisible\n\n</code></pre> <p>Given a user query and, optionally, the conversation history, the local search method identifies a set of entities from the knowledge graph that are semantically-related to the user input. These entities serve as access points into the knowledge graph, enabling the extraction of further relevant details such as connected entities, relationships, entity covariates, and community reports. Additionally, it also extracts relevant text chunks from the raw input documents that are associated with the identified entities. These candidate data sources are then prioritized and filtered to fit within a single context window of pre-defined size, which is used to generate a response to the user query.</p>"}, {"location": "query/local_search/#configuration", "title": "Configuration", "text": "<p>Below are the key parameters of the LocalSearch class:</p> <ul> <li><code>llm</code>: OpenAI model object to be used for response generation</li> <li><code>context_builder</code>: context builder object to be used for preparing context data from collections of knowledge model objects</li> <li><code>system_prompt</code>: prompt template used to generate the search response. Default template can be found at system_prompt</li> <li><code>response_type</code>: free-form text describing the desired response type and format (e.g., <code>Multiple Paragraphs</code>, <code>Multi-Page Report</code>)</li> <li><code>llm_params</code>: a dictionary of additional parameters (e.g., temperature, max_tokens) to be passed to the LLM call</li> <li><code>context_builder_params</code>: a dictionary of additional parameters to be passed to the <code>context_builder</code> object when building context for the search prompt</li> <li><code>callbacks</code>: optional callback functions, can be used to provide custom event handlers for LLM's completion streaming events</li> </ul>"}, {"location": "query/local_search/#how-to-use", "title": "How to Use", "text": "<p>An example of a local search scenario can be found in the following notebook.</p>"}, {"location": "query/overview/", "title": "Query Engine  \ud83d\udd0e", "text": "<p>The Query Engine is the retrieval module of the Graph RAG Library. It is one of the two main components of the Graph RAG library, the other being the Indexing Pipeline (see Indexing Pipeline). It is responsible for the following tasks:</p> <ul> <li>Local Search</li> <li>Global Search</li> <li>Question Generation</li> </ul>"}, {"location": "query/overview/#local-search", "title": "Local Search", "text": "<p>Local search method generates answers by combining relevant data from the AI-extracted knowledge-graph with text chunks of the raw documents. This method is suitable for questions that require an understanding of specific entities mentioned in the documents (e.g. What are the healing properties of chamomile?).</p> <p>For more details about how Local Search works please refer to the Local Search documentation.</p>"}, {"location": "query/overview/#global-search", "title": "Global Search", "text": "<p>Global search method generates answers by searching over all AI-generated community reports in a map-reduce fashion. This is a resource-intensive method, but often gives good responses for questions that require an understanding of the dataset as a whole (e.g. What are the most significant values of the herbs mentioned in this notebook?).</p> <p>More about this can be checked at the Global Search documentation.</p>"}, {"location": "query/overview/#question-generation", "title": "Question Generation", "text": "<p>This functionality takes a list of user queries and generates the next candidate questions. This is useful for generating follow-up questions in a conversation or for generating a list of questions for the investigator to dive deeper into the dataset.</p> <p>Information about how question generation works can be found at the Question Generation documentation page.</p>"}, {"location": "query/question_generation/", "title": "Question Generation \u2754", "text": ""}, {"location": "query/question_generation/#entity-based-question-generation", "title": "Entity-based Question Generation", "text": "<p>The question generation method combines structured data from the knowledge graph with unstructured data from the input documents to generate candidate questions related to specific entities.</p>"}, {"location": "query/question_generation/#methodology", "title": "Methodology", "text": "<p>Given a list of prior user questions, the question generation method uses the same context-building approach employed in local search to extract and prioritize relevant structured and unstructured data, including entities, relationships, covariates, community reports and raw text chunks. These data records are then fitted into a single LLM prompt to generate candidate follow-up questions that represent the most important or urgent information content or themes in the data.</p>"}, {"location": "query/question_generation/#configuration", "title": "Configuration", "text": "<p>Below are the key parameters of the Question Generation class:</p> <ul> <li><code>llm</code>: OpenAI model object to be used for response generation</li> <li><code>context_builder</code>: context builder object to be used for preparing context data from collections of knowledge model objects, using the same context builder class as in local search</li> <li><code>system_prompt</code>: prompt template used to generate candidate questions. Default template can be found at system_prompt</li> <li><code>llm_params</code>: a dictionary of additional parameters (e.g., temperature, max_tokens) to be passed to the LLM call</li> <li><code>context_builder_params</code>: a dictionary of additional parameters to be passed to the <code>context_builder</code> object when building context for the question generation prompt</li> <li><code>callbacks</code>: optional callback functions, can be used to provide custom event handlers for LLM's completion streaming events</li> </ul>"}, {"location": "query/question_generation/#how-to-use", "title": "How to Use", "text": "<p>An example of the question generation function can be found in the following notebook.</p>"}, {"location": "query/notebooks/overview/", "title": "Query Engine Notebooks", "text": "<p>For examples about running Query please refer to the following notebooks:</p> <ul> <li>Global Search Notebook</li> <li>Local Search Notebook</li> </ul> <p>The test dataset for these notebooks can be found in dataset.zip.</p>"}]}